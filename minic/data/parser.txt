Grammar:

Rule 0     S' -> program
Rule 1     program -> decl_list
Rule 2     decl_list -> decl
Rule 3     decl_list -> decl_list decl
Rule 4     decl -> fun_decl
Rule 5     decl -> var_decl
Rule 6     var_decl -> type_spec IDENT [ expr ] ;
Rule 7     var_decl -> type_spec IDENT = expr ;
Rule 8     var_decl -> type_spec IDENT ;
Rule 9     type_spec -> CHAR
Rule 10    type_spec -> FLOAT
Rule 11    type_spec -> INT
Rule 12    type_spec -> BOOL
Rule 13    type_spec -> VOID
Rule 14    fun_decl -> type_spec IDENT ( params ) compound_stmt  [precedence=left, level=12]
Rule 15    params -> VOID
Rule 16    params -> param_list
Rule 17    param_list -> param
Rule 18    param_list -> param_list , param  [precedence=left, level=3]
Rule 19    param -> type_spec IDENT [ ]  [precedence=left, level=12]
Rule 20    param -> type_spec IDENT
Rule 21    compound_stmt -> { local_decls stmt_list }
Rule 22    local_decls -> empty
Rule 23    local_decls -> local_decls local_decl
Rule 24    local_decl -> type_spec IDENT [ expr ] ;
Rule 25    local_decl -> type_spec IDENT = expr ;
Rule 26    local_decl -> type_spec IDENT ;
Rule 27    stmt_list -> empty
Rule 28    stmt_list -> stmt_list stmt
Rule 29    stmt -> break_stmt
Rule 30    stmt -> return_stmt
Rule 31    stmt -> for_stmt
Rule 32    stmt -> while_stmt
Rule 33    stmt -> if_stmt
Rule 34    stmt -> compound_stmt
Rule 35    stmt -> expr_stmt
Rule 36    expr_stmt -> ;
Rule 37    expr_stmt -> expr ;
Rule 38    while_stmt -> WHILE ( expr ) stmt  [precedence=left, level=12]
Rule 39    for_stmt -> FOR ( args ; args ; args ) stmt  [precedence=left, level=12]
Rule 40    if_stmt -> IF ( expr ) stmt ELSE stmt  [precedence=nonassoc, level=2]
Rule 41    if_stmt -> IF ( expr ) stmt  [precedence=nonassoc, level=1]
Rule 42    return_stmt -> RETURN expr ;
Rule 43    return_stmt -> RETURN ;
Rule 44    break_stmt -> BREAK ;
Rule 45    expr -> NEW type_spec [ expr ]  [precedence=left, level=12]
Rule 46    expr -> STRING_LIT
Rule 47    expr -> CHAR_LIT
Rule 48    expr -> FLOAT_LIT
Rule 49    expr -> INT_LIT
Rule 50    expr -> FALSE
Rule 51    expr -> TRUE
Rule 52    expr -> BOOL_LIT
Rule 53    expr -> IDENT . SIZE
Rule 54    expr -> IDENT ( args )  [precedence=left, level=12]
Rule 55    expr -> IDENT [ expr ]  [precedence=left, level=12]
Rule 56    expr -> IDENT
Rule 57    expr -> ( expr )  [precedence=left, level=12]
Rule 58    expr -> expr DEC  [precedence=left, level=12]
Rule 59    expr -> expr INC  [precedence=left, level=12]
Rule 60    expr -> DEC expr  [precedence=right, level=11]
Rule 61    expr -> INC expr  [precedence=right, level=11]
Rule 62    expr -> PLUS expr  [precedence=right, level=11]
Rule 63    expr -> MINUS expr  [precedence=right, level=11]
Rule 64    expr -> ! expr  [precedence=right, level=11]
Rule 65    expr -> expr MOD expr  [precedence=left, level=10]
Rule 66    expr -> expr DIVIDE expr  [precedence=left, level=10]
Rule 67    expr -> expr TIMES expr  [precedence=left, level=10]
Rule 68    expr -> expr MINUS expr  [precedence=left, level=9]
Rule 69    expr -> expr PLUS expr  [precedence=left, level=9]
Rule 70    expr -> expr > expr  [precedence=left, level=8]
Rule 71    expr -> expr GE expr  [precedence=left, level=8]
Rule 72    expr -> expr < expr  [precedence=left, level=8]
Rule 73    expr -> expr LE expr  [precedence=left, level=8]
Rule 74    expr -> expr NE expr  [precedence=left, level=7]
Rule 75    expr -> expr EQ expr  [precedence=left, level=7]
Rule 76    expr -> expr AND expr  [precedence=left, level=6]
Rule 77    expr -> expr OR expr  [precedence=left, level=5]
Rule 78    expr -> IDENT [ expr ] = expr  [precedence=right, level=4]
Rule 79    expr -> IDENT MODASSIGN expr  [precedence=right, level=4]
Rule 80    expr -> IDENT DIVASSIGN expr  [precedence=right, level=4]
Rule 81    expr -> IDENT MULASSIGN expr  [precedence=right, level=4]
Rule 82    expr -> IDENT SUBASSIGN expr  [precedence=right, level=4]
Rule 83    expr -> IDENT ADDASSIGN expr  [precedence=right, level=4]
Rule 84    expr -> IDENT = expr  [precedence=right, level=4]
Rule 85    arg_list -> expr
Rule 86    arg_list -> arg_list , expr  [precedence=left, level=3]
Rule 87    args -> empty
Rule 88    args -> arg_list
Rule 89    empty -> <empty>

Terminals, with rules where they appear:

!                    : 64
(                    : 14 38 39 40 41 54 57
)                    : 14 38 39 40 41 54 57
,                    : 18 86
.                    : 53
;                    : 6 7 8 24 25 26 36 37 39 39 42 43 44
<                    : 72
=                    : 7 25 78 84
>                    : 70
ADDASSIGN            : 83
AND                  : 76
BOOL                 : 12
BOOL_LIT             : 52
BREAK                : 44
CHAR                 : 9
CHAR_LIT             : 47
DEC                  : 58 60
DIVASSIGN            : 80
DIVIDE               : 66
ELSE                 : 40
EQ                   : 75
FALSE                : 50
FLOAT                : 10
FLOAT_LIT            : 48
FOR                  : 39
GE                   : 71
IDENT                : 6 7 8 14 19 20 24 25 26 53 54 55 56 78 79 80 81 82 83 84
IF                   : 40 41
INC                  : 59 61
INT                  : 11
INT_LIT              : 49
LE                   : 73
MINUS                : 63 68
MOD                  : 65
MODASSIGN            : 79
MULASSIGN            : 81
NE                   : 74
NEW                  : 45
OR                   : 77
PLUS                 : 62 69
RETURN               : 42 43
SIZE                 : 53
STRING_LIT           : 46
SUBASSIGN            : 82
TIMES                : 67
TRUE                 : 51
VOID                 : 13 15
WHILE                : 38
[                    : 6 19 24 45 55 78
]                    : 6 19 24 45 55 78
error                : 
{                    : 21
}                    : 21

Nonterminals, with rules where they appear:

arg_list             : 86 88
args                 : 39 39 39 54
break_stmt           : 29
compound_stmt        : 14 34
decl                 : 2 3
decl_list            : 1 3
empty                : 22 27 87
expr                 : 6 7 24 25 37 38 40 41 42 45 55 57 58 59 60 61 62 63 64 65 65 66 66 67 67 68 68 69 69 70 70 71 71 72 72 73 73 74 74 75 75 76 76 77 77 78 78 79 80 81 82 83 84 85 86
expr_stmt            : 35
for_stmt             : 31
fun_decl             : 4
if_stmt              : 33
local_decl           : 23
local_decls          : 21 23
param                : 17 18
param_list           : 16 18
params               : 14
program              : 0
return_stmt          : 30
stmt                 : 28 38 39 40 40 41
stmt_list            : 21 28
type_spec            : 6 7 8 14 19 20 24 25 26 45
var_decl             : 5
while_stmt           : 32


state 0

    (0) S' -> . program
    (1) program -> . decl_list
    (2) decl_list -> . decl
    (3) decl_list -> . decl_list decl
    (4) decl -> . fun_decl
    (5) decl -> . var_decl
    (14) fun_decl -> . type_spec IDENT ( params ) compound_stmt
    (6) var_decl -> . type_spec IDENT [ expr ] ;
    (7) var_decl -> . type_spec IDENT = expr ;
    (8) var_decl -> . type_spec IDENT ;
    (9) type_spec -> . CHAR
    (10) type_spec -> . FLOAT
    (11) type_spec -> . INT
    (12) type_spec -> . BOOL
    (13) type_spec -> . VOID
    CHAR            shift and go to state 7
    FLOAT           shift and go to state 8
    INT             shift and go to state 9
    BOOL            shift and go to state 10
    VOID            shift and go to state 11

    program                        shift and go to state 1
    decl_list                      shift and go to state 2
    decl                           shift and go to state 3
    fun_decl                       shift and go to state 4
    var_decl                       shift and go to state 5
    type_spec                      shift and go to state 6

state 1

    (0) S' -> program .


state 2

    (1) program -> decl_list .
    (3) decl_list -> decl_list . decl
    (4) decl -> . fun_decl
    (5) decl -> . var_decl
    (14) fun_decl -> . type_spec IDENT ( params ) compound_stmt
    (6) var_decl -> . type_spec IDENT [ expr ] ;
    (7) var_decl -> . type_spec IDENT = expr ;
    (8) var_decl -> . type_spec IDENT ;
    (9) type_spec -> . CHAR
    (10) type_spec -> . FLOAT
    (11) type_spec -> . INT
    (12) type_spec -> . BOOL
    (13) type_spec -> . VOID
    $end            reduce using rule 1 (program -> decl_list .)
    CHAR            shift and go to state 7
    FLOAT           shift and go to state 8
    INT             shift and go to state 9
    BOOL            shift and go to state 10
    VOID            shift and go to state 11

    decl                           shift and go to state 12
    fun_decl                       shift and go to state 4
    var_decl                       shift and go to state 5
    type_spec                      shift and go to state 6

state 3

    (2) decl_list -> decl .
    CHAR            reduce using rule 2 (decl_list -> decl .)
    FLOAT           reduce using rule 2 (decl_list -> decl .)
    INT             reduce using rule 2 (decl_list -> decl .)
    BOOL            reduce using rule 2 (decl_list -> decl .)
    VOID            reduce using rule 2 (decl_list -> decl .)
    $end            reduce using rule 2 (decl_list -> decl .)


state 4

    (4) decl -> fun_decl .
    CHAR            reduce using rule 4 (decl -> fun_decl .)
    FLOAT           reduce using rule 4 (decl -> fun_decl .)
    INT             reduce using rule 4 (decl -> fun_decl .)
    BOOL            reduce using rule 4 (decl -> fun_decl .)
    VOID            reduce using rule 4 (decl -> fun_decl .)
    $end            reduce using rule 4 (decl -> fun_decl .)


state 5

    (5) decl -> var_decl .
    CHAR            reduce using rule 5 (decl -> var_decl .)
    FLOAT           reduce using rule 5 (decl -> var_decl .)
    INT             reduce using rule 5 (decl -> var_decl .)
    BOOL            reduce using rule 5 (decl -> var_decl .)
    VOID            reduce using rule 5 (decl -> var_decl .)
    $end            reduce using rule 5 (decl -> var_decl .)


state 6

    (14) fun_decl -> type_spec . IDENT ( params ) compound_stmt
    (6) var_decl -> type_spec . IDENT [ expr ] ;
    (7) var_decl -> type_spec . IDENT = expr ;
    (8) var_decl -> type_spec . IDENT ;
    IDENT           shift and go to state 13


state 7

    (9) type_spec -> CHAR .
    IDENT           reduce using rule 9 (type_spec -> CHAR .)
    [               reduce using rule 9 (type_spec -> CHAR .)


state 8

    (10) type_spec -> FLOAT .
    IDENT           reduce using rule 10 (type_spec -> FLOAT .)
    [               reduce using rule 10 (type_spec -> FLOAT .)


state 9

    (11) type_spec -> INT .
    IDENT           reduce using rule 11 (type_spec -> INT .)
    [               reduce using rule 11 (type_spec -> INT .)


state 10

    (12) type_spec -> BOOL .
    IDENT           reduce using rule 12 (type_spec -> BOOL .)
    [               reduce using rule 12 (type_spec -> BOOL .)


state 11

    (13) type_spec -> VOID .
    IDENT           reduce using rule 13 (type_spec -> VOID .)
    [               reduce using rule 13 (type_spec -> VOID .)


state 12

    (3) decl_list -> decl_list decl .
    CHAR            reduce using rule 3 (decl_list -> decl_list decl .)
    FLOAT           reduce using rule 3 (decl_list -> decl_list decl .)
    INT             reduce using rule 3 (decl_list -> decl_list decl .)
    BOOL            reduce using rule 3 (decl_list -> decl_list decl .)
    VOID            reduce using rule 3 (decl_list -> decl_list decl .)
    $end            reduce using rule 3 (decl_list -> decl_list decl .)


state 13

    (14) fun_decl -> type_spec IDENT . ( params ) compound_stmt
    (6) var_decl -> type_spec IDENT . [ expr ] ;
    (7) var_decl -> type_spec IDENT . = expr ;
    (8) var_decl -> type_spec IDENT . ;
    (               shift and go to state 14
    [               shift and go to state 15
    =               shift and go to state 17
    ;               shift and go to state 16


state 14

    (14) fun_decl -> type_spec IDENT ( . params ) compound_stmt
    (15) params -> . VOID
    (16) params -> . param_list
    (17) param_list -> . param
    (18) param_list -> . param_list , param
    (19) param -> . type_spec IDENT [ ]
    (20) param -> . type_spec IDENT
    (9) type_spec -> . CHAR
    (10) type_spec -> . FLOAT
    (11) type_spec -> . INT
    (12) type_spec -> . BOOL
    (13) type_spec -> . VOID
    VOID            shift and go to state 20
    CHAR            shift and go to state 7
    FLOAT           shift and go to state 8
    INT             shift and go to state 9
    BOOL            shift and go to state 10

    type_spec                      shift and go to state 18
    params                         shift and go to state 19
    param_list                     shift and go to state 21
    param                          shift and go to state 22

state 15

    (6) var_decl -> type_spec IDENT [ . expr ] ;
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING_LIT
    (47) expr -> . CHAR_LIT
    (48) expr -> . FLOAT_LIT
    (49) expr -> . INT_LIT
    (50) expr -> . FALSE
    (51) expr -> . TRUE
    (52) expr -> . BOOL_LIT
    (53) expr -> . IDENT . SIZE
    (54) expr -> . IDENT ( args )
    (55) expr -> . IDENT [ expr ]
    (56) expr -> . IDENT
    (57) expr -> . ( expr )
    (58) expr -> . expr DEC
    (59) expr -> . expr INC
    (60) expr -> . DEC expr
    (61) expr -> . INC expr
    (62) expr -> . PLUS expr
    (63) expr -> . MINUS expr
    (64) expr -> . ! expr
    (65) expr -> . expr MOD expr
    (66) expr -> . expr DIVIDE expr
    (67) expr -> . expr TIMES expr
    (68) expr -> . expr MINUS expr
    (69) expr -> . expr PLUS expr
    (70) expr -> . expr > expr
    (71) expr -> . expr GE expr
    (72) expr -> . expr < expr
    (73) expr -> . expr LE expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT [ expr ] = expr
    (79) expr -> . IDENT MODASSIGN expr
    (80) expr -> . IDENT DIVASSIGN expr
    (81) expr -> . IDENT MULASSIGN expr
    (82) expr -> . IDENT SUBASSIGN expr
    (83) expr -> . IDENT ADDASSIGN expr
    (84) expr -> . IDENT = expr
    NEW             shift and go to state 25
    STRING_LIT      shift and go to state 26
    CHAR_LIT        shift and go to state 27
    FLOAT_LIT       shift and go to state 28
    INT_LIT         shift and go to state 29
    FALSE           shift and go to state 30
    TRUE            shift and go to state 31
    BOOL_LIT        shift and go to state 32
    IDENT           shift and go to state 23
    (               shift and go to state 33
    DEC             shift and go to state 34
    INC             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    !               shift and go to state 38

    expr                           shift and go to state 24

state 16

    (8) var_decl -> type_spec IDENT ; .
    CHAR            reduce using rule 8 (var_decl -> type_spec IDENT ; .)
    FLOAT           reduce using rule 8 (var_decl -> type_spec IDENT ; .)
    INT             reduce using rule 8 (var_decl -> type_spec IDENT ; .)
    BOOL            reduce using rule 8 (var_decl -> type_spec IDENT ; .)
    VOID            reduce using rule 8 (var_decl -> type_spec IDENT ; .)
    $end            reduce using rule 8 (var_decl -> type_spec IDENT ; .)


state 17

    (7) var_decl -> type_spec IDENT = . expr ;
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING_LIT
    (47) expr -> . CHAR_LIT
    (48) expr -> . FLOAT_LIT
    (49) expr -> . INT_LIT
    (50) expr -> . FALSE
    (51) expr -> . TRUE
    (52) expr -> . BOOL_LIT
    (53) expr -> . IDENT . SIZE
    (54) expr -> . IDENT ( args )
    (55) expr -> . IDENT [ expr ]
    (56) expr -> . IDENT
    (57) expr -> . ( expr )
    (58) expr -> . expr DEC
    (59) expr -> . expr INC
    (60) expr -> . DEC expr
    (61) expr -> . INC expr
    (62) expr -> . PLUS expr
    (63) expr -> . MINUS expr
    (64) expr -> . ! expr
    (65) expr -> . expr MOD expr
    (66) expr -> . expr DIVIDE expr
    (67) expr -> . expr TIMES expr
    (68) expr -> . expr MINUS expr
    (69) expr -> . expr PLUS expr
    (70) expr -> . expr > expr
    (71) expr -> . expr GE expr
    (72) expr -> . expr < expr
    (73) expr -> . expr LE expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT [ expr ] = expr
    (79) expr -> . IDENT MODASSIGN expr
    (80) expr -> . IDENT DIVASSIGN expr
    (81) expr -> . IDENT MULASSIGN expr
    (82) expr -> . IDENT SUBASSIGN expr
    (83) expr -> . IDENT ADDASSIGN expr
    (84) expr -> . IDENT = expr
    NEW             shift and go to state 25
    STRING_LIT      shift and go to state 26
    CHAR_LIT        shift and go to state 27
    FLOAT_LIT       shift and go to state 28
    INT_LIT         shift and go to state 29
    FALSE           shift and go to state 30
    TRUE            shift and go to state 31
    BOOL_LIT        shift and go to state 32
    IDENT           shift and go to state 23
    (               shift and go to state 33
    DEC             shift and go to state 34
    INC             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    !               shift and go to state 38

    expr                           shift and go to state 39

state 18

    (19) param -> type_spec . IDENT [ ]
    (20) param -> type_spec . IDENT
    IDENT           shift and go to state 40


state 19

    (14) fun_decl -> type_spec IDENT ( params . ) compound_stmt
    )               shift and go to state 41


state 20

    (15) params -> VOID .
    (13) type_spec -> VOID .
    )               reduce using rule 15 (params -> VOID .)
    IDENT           reduce using rule 13 (type_spec -> VOID .)


state 21

    (16) params -> param_list .
    (18) param_list -> param_list . , param
    )               reduce using rule 16 (params -> param_list .)
    ,               shift and go to state 42


state 22

    (17) param_list -> param .
    ,               reduce using rule 17 (param_list -> param .)
    )               reduce using rule 17 (param_list -> param .)


state 23

    (53) expr -> IDENT . . SIZE
    (54) expr -> IDENT . ( args )
    (55) expr -> IDENT . [ expr ]
    (56) expr -> IDENT .
    (78) expr -> IDENT . [ expr ] = expr
    (79) expr -> IDENT . MODASSIGN expr
    (80) expr -> IDENT . DIVASSIGN expr
    (81) expr -> IDENT . MULASSIGN expr
    (82) expr -> IDENT . SUBASSIGN expr
    (83) expr -> IDENT . ADDASSIGN expr
    (84) expr -> IDENT . = expr
    .               shift and go to state 43
    (               shift and go to state 44
    [               shift and go to state 45
    ]               reduce using rule 56 (expr -> IDENT .)
    DEC             reduce using rule 56 (expr -> IDENT .)
    INC             reduce using rule 56 (expr -> IDENT .)
    MOD             reduce using rule 56 (expr -> IDENT .)
    DIVIDE          reduce using rule 56 (expr -> IDENT .)
    TIMES           reduce using rule 56 (expr -> IDENT .)
    MINUS           reduce using rule 56 (expr -> IDENT .)
    PLUS            reduce using rule 56 (expr -> IDENT .)
    >               reduce using rule 56 (expr -> IDENT .)
    GE              reduce using rule 56 (expr -> IDENT .)
    <               reduce using rule 56 (expr -> IDENT .)
    LE              reduce using rule 56 (expr -> IDENT .)
    NE              reduce using rule 56 (expr -> IDENT .)
    EQ              reduce using rule 56 (expr -> IDENT .)
    AND             reduce using rule 56 (expr -> IDENT .)
    OR              reduce using rule 56 (expr -> IDENT .)
    ;               reduce using rule 56 (expr -> IDENT .)
    )               reduce using rule 56 (expr -> IDENT .)
    ,               reduce using rule 56 (expr -> IDENT .)
    MODASSIGN       shift and go to state 47
    DIVASSIGN       shift and go to state 48
    MULASSIGN       shift and go to state 49
    SUBASSIGN       shift and go to state 50
    ADDASSIGN       shift and go to state 51
    =               shift and go to state 46


state 24

    (6) var_decl -> type_spec IDENT [ expr . ] ;
    (58) expr -> expr . DEC
    (59) expr -> expr . INC
    (65) expr -> expr . MOD expr
    (66) expr -> expr . DIVIDE expr
    (67) expr -> expr . TIMES expr
    (68) expr -> expr . MINUS expr
    (69) expr -> expr . PLUS expr
    (70) expr -> expr . > expr
    (71) expr -> expr . GE expr
    (72) expr -> expr . < expr
    (73) expr -> expr . LE expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    ]               shift and go to state 52
    DEC             shift and go to state 53
    INC             shift and go to state 54
    MOD             shift and go to state 55
    DIVIDE          shift and go to state 56
    TIMES           shift and go to state 57
    MINUS           shift and go to state 58
    PLUS            shift and go to state 59
    >               shift and go to state 60
    GE              shift and go to state 61
    <               shift and go to state 62
    LE              shift and go to state 63
    NE              shift and go to state 64
    EQ              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 25

    (45) expr -> NEW . type_spec [ expr ]
    (9) type_spec -> . CHAR
    (10) type_spec -> . FLOAT
    (11) type_spec -> . INT
    (12) type_spec -> . BOOL
    (13) type_spec -> . VOID
    CHAR            shift and go to state 7
    FLOAT           shift and go to state 8
    INT             shift and go to state 9
    BOOL            shift and go to state 10
    VOID            shift and go to state 11

    type_spec                      shift and go to state 68

state 26

    (46) expr -> STRING_LIT .
    ]               reduce using rule 46 (expr -> STRING_LIT .)
    DEC             reduce using rule 46 (expr -> STRING_LIT .)
    INC             reduce using rule 46 (expr -> STRING_LIT .)
    MOD             reduce using rule 46 (expr -> STRING_LIT .)
    DIVIDE          reduce using rule 46 (expr -> STRING_LIT .)
    TIMES           reduce using rule 46 (expr -> STRING_LIT .)
    MINUS           reduce using rule 46 (expr -> STRING_LIT .)
    PLUS            reduce using rule 46 (expr -> STRING_LIT .)
    >               reduce using rule 46 (expr -> STRING_LIT .)
    GE              reduce using rule 46 (expr -> STRING_LIT .)
    <               reduce using rule 46 (expr -> STRING_LIT .)
    LE              reduce using rule 46 (expr -> STRING_LIT .)
    NE              reduce using rule 46 (expr -> STRING_LIT .)
    EQ              reduce using rule 46 (expr -> STRING_LIT .)
    AND             reduce using rule 46 (expr -> STRING_LIT .)
    OR              reduce using rule 46 (expr -> STRING_LIT .)
    ;               reduce using rule 46 (expr -> STRING_LIT .)
    )               reduce using rule 46 (expr -> STRING_LIT .)
    ,               reduce using rule 46 (expr -> STRING_LIT .)


state 27

    (47) expr -> CHAR_LIT .
    ]               reduce using rule 47 (expr -> CHAR_LIT .)
    DEC             reduce using rule 47 (expr -> CHAR_LIT .)
    INC             reduce using rule 47 (expr -> CHAR_LIT .)
    MOD             reduce using rule 47 (expr -> CHAR_LIT .)
    DIVIDE          reduce using rule 47 (expr -> CHAR_LIT .)
    TIMES           reduce using rule 47 (expr -> CHAR_LIT .)
    MINUS           reduce using rule 47 (expr -> CHAR_LIT .)
    PLUS            reduce using rule 47 (expr -> CHAR_LIT .)
    >               reduce using rule 47 (expr -> CHAR_LIT .)
    GE              reduce using rule 47 (expr -> CHAR_LIT .)
    <               reduce using rule 47 (expr -> CHAR_LIT .)
    LE              reduce using rule 47 (expr -> CHAR_LIT .)
    NE              reduce using rule 47 (expr -> CHAR_LIT .)
    EQ              reduce using rule 47 (expr -> CHAR_LIT .)
    AND             reduce using rule 47 (expr -> CHAR_LIT .)
    OR              reduce using rule 47 (expr -> CHAR_LIT .)
    ;               reduce using rule 47 (expr -> CHAR_LIT .)
    )               reduce using rule 47 (expr -> CHAR_LIT .)
    ,               reduce using rule 47 (expr -> CHAR_LIT .)


state 28

    (48) expr -> FLOAT_LIT .
    ]               reduce using rule 48 (expr -> FLOAT_LIT .)
    DEC             reduce using rule 48 (expr -> FLOAT_LIT .)
    INC             reduce using rule 48 (expr -> FLOAT_LIT .)
    MOD             reduce using rule 48 (expr -> FLOAT_LIT .)
    DIVIDE          reduce using rule 48 (expr -> FLOAT_LIT .)
    TIMES           reduce using rule 48 (expr -> FLOAT_LIT .)
    MINUS           reduce using rule 48 (expr -> FLOAT_LIT .)
    PLUS            reduce using rule 48 (expr -> FLOAT_LIT .)
    >               reduce using rule 48 (expr -> FLOAT_LIT .)
    GE              reduce using rule 48 (expr -> FLOAT_LIT .)
    <               reduce using rule 48 (expr -> FLOAT_LIT .)
    LE              reduce using rule 48 (expr -> FLOAT_LIT .)
    NE              reduce using rule 48 (expr -> FLOAT_LIT .)
    EQ              reduce using rule 48 (expr -> FLOAT_LIT .)
    AND             reduce using rule 48 (expr -> FLOAT_LIT .)
    OR              reduce using rule 48 (expr -> FLOAT_LIT .)
    ;               reduce using rule 48 (expr -> FLOAT_LIT .)
    )               reduce using rule 48 (expr -> FLOAT_LIT .)
    ,               reduce using rule 48 (expr -> FLOAT_LIT .)


state 29

    (49) expr -> INT_LIT .
    ]               reduce using rule 49 (expr -> INT_LIT .)
    DEC             reduce using rule 49 (expr -> INT_LIT .)
    INC             reduce using rule 49 (expr -> INT_LIT .)
    MOD             reduce using rule 49 (expr -> INT_LIT .)
    DIVIDE          reduce using rule 49 (expr -> INT_LIT .)
    TIMES           reduce using rule 49 (expr -> INT_LIT .)
    MINUS           reduce using rule 49 (expr -> INT_LIT .)
    PLUS            reduce using rule 49 (expr -> INT_LIT .)
    >               reduce using rule 49 (expr -> INT_LIT .)
    GE              reduce using rule 49 (expr -> INT_LIT .)
    <               reduce using rule 49 (expr -> INT_LIT .)
    LE              reduce using rule 49 (expr -> INT_LIT .)
    NE              reduce using rule 49 (expr -> INT_LIT .)
    EQ              reduce using rule 49 (expr -> INT_LIT .)
    AND             reduce using rule 49 (expr -> INT_LIT .)
    OR              reduce using rule 49 (expr -> INT_LIT .)
    ;               reduce using rule 49 (expr -> INT_LIT .)
    )               reduce using rule 49 (expr -> INT_LIT .)
    ,               reduce using rule 49 (expr -> INT_LIT .)


state 30

    (50) expr -> FALSE .
    ]               reduce using rule 50 (expr -> FALSE .)
    DEC             reduce using rule 50 (expr -> FALSE .)
    INC             reduce using rule 50 (expr -> FALSE .)
    MOD             reduce using rule 50 (expr -> FALSE .)
    DIVIDE          reduce using rule 50 (expr -> FALSE .)
    TIMES           reduce using rule 50 (expr -> FALSE .)
    MINUS           reduce using rule 50 (expr -> FALSE .)
    PLUS            reduce using rule 50 (expr -> FALSE .)
    >               reduce using rule 50 (expr -> FALSE .)
    GE              reduce using rule 50 (expr -> FALSE .)
    <               reduce using rule 50 (expr -> FALSE .)
    LE              reduce using rule 50 (expr -> FALSE .)
    NE              reduce using rule 50 (expr -> FALSE .)
    EQ              reduce using rule 50 (expr -> FALSE .)
    AND             reduce using rule 50 (expr -> FALSE .)
    OR              reduce using rule 50 (expr -> FALSE .)
    ;               reduce using rule 50 (expr -> FALSE .)
    )               reduce using rule 50 (expr -> FALSE .)
    ,               reduce using rule 50 (expr -> FALSE .)


state 31

    (51) expr -> TRUE .
    ]               reduce using rule 51 (expr -> TRUE .)
    DEC             reduce using rule 51 (expr -> TRUE .)
    INC             reduce using rule 51 (expr -> TRUE .)
    MOD             reduce using rule 51 (expr -> TRUE .)
    DIVIDE          reduce using rule 51 (expr -> TRUE .)
    TIMES           reduce using rule 51 (expr -> TRUE .)
    MINUS           reduce using rule 51 (expr -> TRUE .)
    PLUS            reduce using rule 51 (expr -> TRUE .)
    >               reduce using rule 51 (expr -> TRUE .)
    GE              reduce using rule 51 (expr -> TRUE .)
    <               reduce using rule 51 (expr -> TRUE .)
    LE              reduce using rule 51 (expr -> TRUE .)
    NE              reduce using rule 51 (expr -> TRUE .)
    EQ              reduce using rule 51 (expr -> TRUE .)
    AND             reduce using rule 51 (expr -> TRUE .)
    OR              reduce using rule 51 (expr -> TRUE .)
    ;               reduce using rule 51 (expr -> TRUE .)
    )               reduce using rule 51 (expr -> TRUE .)
    ,               reduce using rule 51 (expr -> TRUE .)


state 32

    (52) expr -> BOOL_LIT .
    ]               reduce using rule 52 (expr -> BOOL_LIT .)
    DEC             reduce using rule 52 (expr -> BOOL_LIT .)
    INC             reduce using rule 52 (expr -> BOOL_LIT .)
    MOD             reduce using rule 52 (expr -> BOOL_LIT .)
    DIVIDE          reduce using rule 52 (expr -> BOOL_LIT .)
    TIMES           reduce using rule 52 (expr -> BOOL_LIT .)
    MINUS           reduce using rule 52 (expr -> BOOL_LIT .)
    PLUS            reduce using rule 52 (expr -> BOOL_LIT .)
    >               reduce using rule 52 (expr -> BOOL_LIT .)
    GE              reduce using rule 52 (expr -> BOOL_LIT .)
    <               reduce using rule 52 (expr -> BOOL_LIT .)
    LE              reduce using rule 52 (expr -> BOOL_LIT .)
    NE              reduce using rule 52 (expr -> BOOL_LIT .)
    EQ              reduce using rule 52 (expr -> BOOL_LIT .)
    AND             reduce using rule 52 (expr -> BOOL_LIT .)
    OR              reduce using rule 52 (expr -> BOOL_LIT .)
    ;               reduce using rule 52 (expr -> BOOL_LIT .)
    )               reduce using rule 52 (expr -> BOOL_LIT .)
    ,               reduce using rule 52 (expr -> BOOL_LIT .)


state 33

    (57) expr -> ( . expr )
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING_LIT
    (47) expr -> . CHAR_LIT
    (48) expr -> . FLOAT_LIT
    (49) expr -> . INT_LIT
    (50) expr -> . FALSE
    (51) expr -> . TRUE
    (52) expr -> . BOOL_LIT
    (53) expr -> . IDENT . SIZE
    (54) expr -> . IDENT ( args )
    (55) expr -> . IDENT [ expr ]
    (56) expr -> . IDENT
    (57) expr -> . ( expr )
    (58) expr -> . expr DEC
    (59) expr -> . expr INC
    (60) expr -> . DEC expr
    (61) expr -> . INC expr
    (62) expr -> . PLUS expr
    (63) expr -> . MINUS expr
    (64) expr -> . ! expr
    (65) expr -> . expr MOD expr
    (66) expr -> . expr DIVIDE expr
    (67) expr -> . expr TIMES expr
    (68) expr -> . expr MINUS expr
    (69) expr -> . expr PLUS expr
    (70) expr -> . expr > expr
    (71) expr -> . expr GE expr
    (72) expr -> . expr < expr
    (73) expr -> . expr LE expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT [ expr ] = expr
    (79) expr -> . IDENT MODASSIGN expr
    (80) expr -> . IDENT DIVASSIGN expr
    (81) expr -> . IDENT MULASSIGN expr
    (82) expr -> . IDENT SUBASSIGN expr
    (83) expr -> . IDENT ADDASSIGN expr
    (84) expr -> . IDENT = expr
    NEW             shift and go to state 25
    STRING_LIT      shift and go to state 26
    CHAR_LIT        shift and go to state 27
    FLOAT_LIT       shift and go to state 28
    INT_LIT         shift and go to state 29
    FALSE           shift and go to state 30
    TRUE            shift and go to state 31
    BOOL_LIT        shift and go to state 32
    IDENT           shift and go to state 23
    (               shift and go to state 33
    DEC             shift and go to state 34
    INC             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    !               shift and go to state 38

    expr                           shift and go to state 69

state 34

    (60) expr -> DEC . expr
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING_LIT
    (47) expr -> . CHAR_LIT
    (48) expr -> . FLOAT_LIT
    (49) expr -> . INT_LIT
    (50) expr -> . FALSE
    (51) expr -> . TRUE
    (52) expr -> . BOOL_LIT
    (53) expr -> . IDENT . SIZE
    (54) expr -> . IDENT ( args )
    (55) expr -> . IDENT [ expr ]
    (56) expr -> . IDENT
    (57) expr -> . ( expr )
    (58) expr -> . expr DEC
    (59) expr -> . expr INC
    (60) expr -> . DEC expr
    (61) expr -> . INC expr
    (62) expr -> . PLUS expr
    (63) expr -> . MINUS expr
    (64) expr -> . ! expr
    (65) expr -> . expr MOD expr
    (66) expr -> . expr DIVIDE expr
    (67) expr -> . expr TIMES expr
    (68) expr -> . expr MINUS expr
    (69) expr -> . expr PLUS expr
    (70) expr -> . expr > expr
    (71) expr -> . expr GE expr
    (72) expr -> . expr < expr
    (73) expr -> . expr LE expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT [ expr ] = expr
    (79) expr -> . IDENT MODASSIGN expr
    (80) expr -> . IDENT DIVASSIGN expr
    (81) expr -> . IDENT MULASSIGN expr
    (82) expr -> . IDENT SUBASSIGN expr
    (83) expr -> . IDENT ADDASSIGN expr
    (84) expr -> . IDENT = expr
    NEW             shift and go to state 25
    STRING_LIT      shift and go to state 26
    CHAR_LIT        shift and go to state 27
    FLOAT_LIT       shift and go to state 28
    INT_LIT         shift and go to state 29
    FALSE           shift and go to state 30
    TRUE            shift and go to state 31
    BOOL_LIT        shift and go to state 32
    IDENT           shift and go to state 23
    (               shift and go to state 33
    DEC             shift and go to state 34
    INC             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    !               shift and go to state 38

    expr                           shift and go to state 70

state 35

    (61) expr -> INC . expr
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING_LIT
    (47) expr -> . CHAR_LIT
    (48) expr -> . FLOAT_LIT
    (49) expr -> . INT_LIT
    (50) expr -> . FALSE
    (51) expr -> . TRUE
    (52) expr -> . BOOL_LIT
    (53) expr -> . IDENT . SIZE
    (54) expr -> . IDENT ( args )
    (55) expr -> . IDENT [ expr ]
    (56) expr -> . IDENT
    (57) expr -> . ( expr )
    (58) expr -> . expr DEC
    (59) expr -> . expr INC
    (60) expr -> . DEC expr
    (61) expr -> . INC expr
    (62) expr -> . PLUS expr
    (63) expr -> . MINUS expr
    (64) expr -> . ! expr
    (65) expr -> . expr MOD expr
    (66) expr -> . expr DIVIDE expr
    (67) expr -> . expr TIMES expr
    (68) expr -> . expr MINUS expr
    (69) expr -> . expr PLUS expr
    (70) expr -> . expr > expr
    (71) expr -> . expr GE expr
    (72) expr -> . expr < expr
    (73) expr -> . expr LE expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT [ expr ] = expr
    (79) expr -> . IDENT MODASSIGN expr
    (80) expr -> . IDENT DIVASSIGN expr
    (81) expr -> . IDENT MULASSIGN expr
    (82) expr -> . IDENT SUBASSIGN expr
    (83) expr -> . IDENT ADDASSIGN expr
    (84) expr -> . IDENT = expr
    NEW             shift and go to state 25
    STRING_LIT      shift and go to state 26
    CHAR_LIT        shift and go to state 27
    FLOAT_LIT       shift and go to state 28
    INT_LIT         shift and go to state 29
    FALSE           shift and go to state 30
    TRUE            shift and go to state 31
    BOOL_LIT        shift and go to state 32
    IDENT           shift and go to state 23
    (               shift and go to state 33
    DEC             shift and go to state 34
    INC             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    !               shift and go to state 38

    expr                           shift and go to state 71

state 36

    (62) expr -> PLUS . expr
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING_LIT
    (47) expr -> . CHAR_LIT
    (48) expr -> . FLOAT_LIT
    (49) expr -> . INT_LIT
    (50) expr -> . FALSE
    (51) expr -> . TRUE
    (52) expr -> . BOOL_LIT
    (53) expr -> . IDENT . SIZE
    (54) expr -> . IDENT ( args )
    (55) expr -> . IDENT [ expr ]
    (56) expr -> . IDENT
    (57) expr -> . ( expr )
    (58) expr -> . expr DEC
    (59) expr -> . expr INC
    (60) expr -> . DEC expr
    (61) expr -> . INC expr
    (62) expr -> . PLUS expr
    (63) expr -> . MINUS expr
    (64) expr -> . ! expr
    (65) expr -> . expr MOD expr
    (66) expr -> . expr DIVIDE expr
    (67) expr -> . expr TIMES expr
    (68) expr -> . expr MINUS expr
    (69) expr -> . expr PLUS expr
    (70) expr -> . expr > expr
    (71) expr -> . expr GE expr
    (72) expr -> . expr < expr
    (73) expr -> . expr LE expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT [ expr ] = expr
    (79) expr -> . IDENT MODASSIGN expr
    (80) expr -> . IDENT DIVASSIGN expr
    (81) expr -> . IDENT MULASSIGN expr
    (82) expr -> . IDENT SUBASSIGN expr
    (83) expr -> . IDENT ADDASSIGN expr
    (84) expr -> . IDENT = expr
    NEW             shift and go to state 25
    STRING_LIT      shift and go to state 26
    CHAR_LIT        shift and go to state 27
    FLOAT_LIT       shift and go to state 28
    INT_LIT         shift and go to state 29
    FALSE           shift and go to state 30
    TRUE            shift and go to state 31
    BOOL_LIT        shift and go to state 32
    IDENT           shift and go to state 23
    (               shift and go to state 33
    DEC             shift and go to state 34
    INC             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    !               shift and go to state 38

    expr                           shift and go to state 72

state 37

    (63) expr -> MINUS . expr
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING_LIT
    (47) expr -> . CHAR_LIT
    (48) expr -> . FLOAT_LIT
    (49) expr -> . INT_LIT
    (50) expr -> . FALSE
    (51) expr -> . TRUE
    (52) expr -> . BOOL_LIT
    (53) expr -> . IDENT . SIZE
    (54) expr -> . IDENT ( args )
    (55) expr -> . IDENT [ expr ]
    (56) expr -> . IDENT
    (57) expr -> . ( expr )
    (58) expr -> . expr DEC
    (59) expr -> . expr INC
    (60) expr -> . DEC expr
    (61) expr -> . INC expr
    (62) expr -> . PLUS expr
    (63) expr -> . MINUS expr
    (64) expr -> . ! expr
    (65) expr -> . expr MOD expr
    (66) expr -> . expr DIVIDE expr
    (67) expr -> . expr TIMES expr
    (68) expr -> . expr MINUS expr
    (69) expr -> . expr PLUS expr
    (70) expr -> . expr > expr
    (71) expr -> . expr GE expr
    (72) expr -> . expr < expr
    (73) expr -> . expr LE expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT [ expr ] = expr
    (79) expr -> . IDENT MODASSIGN expr
    (80) expr -> . IDENT DIVASSIGN expr
    (81) expr -> . IDENT MULASSIGN expr
    (82) expr -> . IDENT SUBASSIGN expr
    (83) expr -> . IDENT ADDASSIGN expr
    (84) expr -> . IDENT = expr
    NEW             shift and go to state 25
    STRING_LIT      shift and go to state 26
    CHAR_LIT        shift and go to state 27
    FLOAT_LIT       shift and go to state 28
    INT_LIT         shift and go to state 29
    FALSE           shift and go to state 30
    TRUE            shift and go to state 31
    BOOL_LIT        shift and go to state 32
    IDENT           shift and go to state 23
    (               shift and go to state 33
    DEC             shift and go to state 34
    INC             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    !               shift and go to state 38

    expr                           shift and go to state 73

state 38

    (64) expr -> ! . expr
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING_LIT
    (47) expr -> . CHAR_LIT
    (48) expr -> . FLOAT_LIT
    (49) expr -> . INT_LIT
    (50) expr -> . FALSE
    (51) expr -> . TRUE
    (52) expr -> . BOOL_LIT
    (53) expr -> . IDENT . SIZE
    (54) expr -> . IDENT ( args )
    (55) expr -> . IDENT [ expr ]
    (56) expr -> . IDENT
    (57) expr -> . ( expr )
    (58) expr -> . expr DEC
    (59) expr -> . expr INC
    (60) expr -> . DEC expr
    (61) expr -> . INC expr
    (62) expr -> . PLUS expr
    (63) expr -> . MINUS expr
    (64) expr -> . ! expr
    (65) expr -> . expr MOD expr
    (66) expr -> . expr DIVIDE expr
    (67) expr -> . expr TIMES expr
    (68) expr -> . expr MINUS expr
    (69) expr -> . expr PLUS expr
    (70) expr -> . expr > expr
    (71) expr -> . expr GE expr
    (72) expr -> . expr < expr
    (73) expr -> . expr LE expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT [ expr ] = expr
    (79) expr -> . IDENT MODASSIGN expr
    (80) expr -> . IDENT DIVASSIGN expr
    (81) expr -> . IDENT MULASSIGN expr
    (82) expr -> . IDENT SUBASSIGN expr
    (83) expr -> . IDENT ADDASSIGN expr
    (84) expr -> . IDENT = expr
    NEW             shift and go to state 25
    STRING_LIT      shift and go to state 26
    CHAR_LIT        shift and go to state 27
    FLOAT_LIT       shift and go to state 28
    INT_LIT         shift and go to state 29
    FALSE           shift and go to state 30
    TRUE            shift and go to state 31
    BOOL_LIT        shift and go to state 32
    IDENT           shift and go to state 23
    (               shift and go to state 33
    DEC             shift and go to state 34
    INC             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    !               shift and go to state 38

    expr                           shift and go to state 74

state 39

    (7) var_decl -> type_spec IDENT = expr . ;
    (58) expr -> expr . DEC
    (59) expr -> expr . INC
    (65) expr -> expr . MOD expr
    (66) expr -> expr . DIVIDE expr
    (67) expr -> expr . TIMES expr
    (68) expr -> expr . MINUS expr
    (69) expr -> expr . PLUS expr
    (70) expr -> expr . > expr
    (71) expr -> expr . GE expr
    (72) expr -> expr . < expr
    (73) expr -> expr . LE expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    ;               shift and go to state 75
    DEC             shift and go to state 53
    INC             shift and go to state 54
    MOD             shift and go to state 55
    DIVIDE          shift and go to state 56
    TIMES           shift and go to state 57
    MINUS           shift and go to state 58
    PLUS            shift and go to state 59
    >               shift and go to state 60
    GE              shift and go to state 61
    <               shift and go to state 62
    LE              shift and go to state 63
    NE              shift and go to state 64
    EQ              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 40

    (19) param -> type_spec IDENT . [ ]
    (20) param -> type_spec IDENT .
    [               shift and go to state 76
    ,               reduce using rule 20 (param -> type_spec IDENT .)
    )               reduce using rule 20 (param -> type_spec IDENT .)


state 41

    (14) fun_decl -> type_spec IDENT ( params ) . compound_stmt
    (21) compound_stmt -> . { local_decls stmt_list }
    {               shift and go to state 78

    compound_stmt                  shift and go to state 77

state 42

    (18) param_list -> param_list , . param
    (19) param -> . type_spec IDENT [ ]
    (20) param -> . type_spec IDENT
    (9) type_spec -> . CHAR
    (10) type_spec -> . FLOAT
    (11) type_spec -> . INT
    (12) type_spec -> . BOOL
    (13) type_spec -> . VOID
    CHAR            shift and go to state 7
    FLOAT           shift and go to state 8
    INT             shift and go to state 9
    BOOL            shift and go to state 10
    VOID            shift and go to state 11

    param                          shift and go to state 79
    type_spec                      shift and go to state 18

state 43

    (53) expr -> IDENT . . SIZE
    SIZE            shift and go to state 80


state 44

    (54) expr -> IDENT ( . args )
    (87) args -> . empty
    (88) args -> . arg_list
    (89) empty -> .
    (85) arg_list -> . expr
    (86) arg_list -> . arg_list , expr
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING_LIT
    (47) expr -> . CHAR_LIT
    (48) expr -> . FLOAT_LIT
    (49) expr -> . INT_LIT
    (50) expr -> . FALSE
    (51) expr -> . TRUE
    (52) expr -> . BOOL_LIT
    (53) expr -> . IDENT . SIZE
    (54) expr -> . IDENT ( args )
    (55) expr -> . IDENT [ expr ]
    (56) expr -> . IDENT
    (57) expr -> . ( expr )
    (58) expr -> . expr DEC
    (59) expr -> . expr INC
    (60) expr -> . DEC expr
    (61) expr -> . INC expr
    (62) expr -> . PLUS expr
    (63) expr -> . MINUS expr
    (64) expr -> . ! expr
    (65) expr -> . expr MOD expr
    (66) expr -> . expr DIVIDE expr
    (67) expr -> . expr TIMES expr
    (68) expr -> . expr MINUS expr
    (69) expr -> . expr PLUS expr
    (70) expr -> . expr > expr
    (71) expr -> . expr GE expr
    (72) expr -> . expr < expr
    (73) expr -> . expr LE expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT [ expr ] = expr
    (79) expr -> . IDENT MODASSIGN expr
    (80) expr -> . IDENT DIVASSIGN expr
    (81) expr -> . IDENT MULASSIGN expr
    (82) expr -> . IDENT SUBASSIGN expr
    (83) expr -> . IDENT ADDASSIGN expr
    (84) expr -> . IDENT = expr
    )               reduce using rule 89 (empty -> .)
    NEW             shift and go to state 25
    STRING_LIT      shift and go to state 26
    CHAR_LIT        shift and go to state 27
    FLOAT_LIT       shift and go to state 28
    INT_LIT         shift and go to state 29
    FALSE           shift and go to state 30
    TRUE            shift and go to state 31
    BOOL_LIT        shift and go to state 32
    IDENT           shift and go to state 23
    (               shift and go to state 33
    DEC             shift and go to state 34
    INC             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    !               shift and go to state 38

    args                           shift and go to state 81
    empty                          shift and go to state 82
    arg_list                       shift and go to state 83
    expr                           shift and go to state 84

state 45

    (55) expr -> IDENT [ . expr ]
    (78) expr -> IDENT [ . expr ] = expr
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING_LIT
    (47) expr -> . CHAR_LIT
    (48) expr -> . FLOAT_LIT
    (49) expr -> . INT_LIT
    (50) expr -> . FALSE
    (51) expr -> . TRUE
    (52) expr -> . BOOL_LIT
    (53) expr -> . IDENT . SIZE
    (54) expr -> . IDENT ( args )
    (55) expr -> . IDENT [ expr ]
    (56) expr -> . IDENT
    (57) expr -> . ( expr )
    (58) expr -> . expr DEC
    (59) expr -> . expr INC
    (60) expr -> . DEC expr
    (61) expr -> . INC expr
    (62) expr -> . PLUS expr
    (63) expr -> . MINUS expr
    (64) expr -> . ! expr
    (65) expr -> . expr MOD expr
    (66) expr -> . expr DIVIDE expr
    (67) expr -> . expr TIMES expr
    (68) expr -> . expr MINUS expr
    (69) expr -> . expr PLUS expr
    (70) expr -> . expr > expr
    (71) expr -> . expr GE expr
    (72) expr -> . expr < expr
    (73) expr -> . expr LE expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT [ expr ] = expr
    (79) expr -> . IDENT MODASSIGN expr
    (80) expr -> . IDENT DIVASSIGN expr
    (81) expr -> . IDENT MULASSIGN expr
    (82) expr -> . IDENT SUBASSIGN expr
    (83) expr -> . IDENT ADDASSIGN expr
    (84) expr -> . IDENT = expr
    NEW             shift and go to state 25
    STRING_LIT      shift and go to state 26
    CHAR_LIT        shift and go to state 27
    FLOAT_LIT       shift and go to state 28
    INT_LIT         shift and go to state 29
    FALSE           shift and go to state 30
    TRUE            shift and go to state 31
    BOOL_LIT        shift and go to state 32
    IDENT           shift and go to state 23
    (               shift and go to state 33
    DEC             shift and go to state 34
    INC             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    !               shift and go to state 38

    expr                           shift and go to state 85

state 46

    (84) expr -> IDENT = . expr
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING_LIT
    (47) expr -> . CHAR_LIT
    (48) expr -> . FLOAT_LIT
    (49) expr -> . INT_LIT
    (50) expr -> . FALSE
    (51) expr -> . TRUE
    (52) expr -> . BOOL_LIT
    (53) expr -> . IDENT . SIZE
    (54) expr -> . IDENT ( args )
    (55) expr -> . IDENT [ expr ]
    (56) expr -> . IDENT
    (57) expr -> . ( expr )
    (58) expr -> . expr DEC
    (59) expr -> . expr INC
    (60) expr -> . DEC expr
    (61) expr -> . INC expr
    (62) expr -> . PLUS expr
    (63) expr -> . MINUS expr
    (64) expr -> . ! expr
    (65) expr -> . expr MOD expr
    (66) expr -> . expr DIVIDE expr
    (67) expr -> . expr TIMES expr
    (68) expr -> . expr MINUS expr
    (69) expr -> . expr PLUS expr
    (70) expr -> . expr > expr
    (71) expr -> . expr GE expr
    (72) expr -> . expr < expr
    (73) expr -> . expr LE expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT [ expr ] = expr
    (79) expr -> . IDENT MODASSIGN expr
    (80) expr -> . IDENT DIVASSIGN expr
    (81) expr -> . IDENT MULASSIGN expr
    (82) expr -> . IDENT SUBASSIGN expr
    (83) expr -> . IDENT ADDASSIGN expr
    (84) expr -> . IDENT = expr
    NEW             shift and go to state 25
    STRING_LIT      shift and go to state 26
    CHAR_LIT        shift and go to state 27
    FLOAT_LIT       shift and go to state 28
    INT_LIT         shift and go to state 29
    FALSE           shift and go to state 30
    TRUE            shift and go to state 31
    BOOL_LIT        shift and go to state 32
    IDENT           shift and go to state 23
    (               shift and go to state 33
    DEC             shift and go to state 34
    INC             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    !               shift and go to state 38

    expr                           shift and go to state 86

state 47

    (79) expr -> IDENT MODASSIGN . expr
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING_LIT
    (47) expr -> . CHAR_LIT
    (48) expr -> . FLOAT_LIT
    (49) expr -> . INT_LIT
    (50) expr -> . FALSE
    (51) expr -> . TRUE
    (52) expr -> . BOOL_LIT
    (53) expr -> . IDENT . SIZE
    (54) expr -> . IDENT ( args )
    (55) expr -> . IDENT [ expr ]
    (56) expr -> . IDENT
    (57) expr -> . ( expr )
    (58) expr -> . expr DEC
    (59) expr -> . expr INC
    (60) expr -> . DEC expr
    (61) expr -> . INC expr
    (62) expr -> . PLUS expr
    (63) expr -> . MINUS expr
    (64) expr -> . ! expr
    (65) expr -> . expr MOD expr
    (66) expr -> . expr DIVIDE expr
    (67) expr -> . expr TIMES expr
    (68) expr -> . expr MINUS expr
    (69) expr -> . expr PLUS expr
    (70) expr -> . expr > expr
    (71) expr -> . expr GE expr
    (72) expr -> . expr < expr
    (73) expr -> . expr LE expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT [ expr ] = expr
    (79) expr -> . IDENT MODASSIGN expr
    (80) expr -> . IDENT DIVASSIGN expr
    (81) expr -> . IDENT MULASSIGN expr
    (82) expr -> . IDENT SUBASSIGN expr
    (83) expr -> . IDENT ADDASSIGN expr
    (84) expr -> . IDENT = expr
    NEW             shift and go to state 25
    STRING_LIT      shift and go to state 26
    CHAR_LIT        shift and go to state 27
    FLOAT_LIT       shift and go to state 28
    INT_LIT         shift and go to state 29
    FALSE           shift and go to state 30
    TRUE            shift and go to state 31
    BOOL_LIT        shift and go to state 32
    IDENT           shift and go to state 23
    (               shift and go to state 33
    DEC             shift and go to state 34
    INC             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    !               shift and go to state 38

    expr                           shift and go to state 87

state 48

    (80) expr -> IDENT DIVASSIGN . expr
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING_LIT
    (47) expr -> . CHAR_LIT
    (48) expr -> . FLOAT_LIT
    (49) expr -> . INT_LIT
    (50) expr -> . FALSE
    (51) expr -> . TRUE
    (52) expr -> . BOOL_LIT
    (53) expr -> . IDENT . SIZE
    (54) expr -> . IDENT ( args )
    (55) expr -> . IDENT [ expr ]
    (56) expr -> . IDENT
    (57) expr -> . ( expr )
    (58) expr -> . expr DEC
    (59) expr -> . expr INC
    (60) expr -> . DEC expr
    (61) expr -> . INC expr
    (62) expr -> . PLUS expr
    (63) expr -> . MINUS expr
    (64) expr -> . ! expr
    (65) expr -> . expr MOD expr
    (66) expr -> . expr DIVIDE expr
    (67) expr -> . expr TIMES expr
    (68) expr -> . expr MINUS expr
    (69) expr -> . expr PLUS expr
    (70) expr -> . expr > expr
    (71) expr -> . expr GE expr
    (72) expr -> . expr < expr
    (73) expr -> . expr LE expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT [ expr ] = expr
    (79) expr -> . IDENT MODASSIGN expr
    (80) expr -> . IDENT DIVASSIGN expr
    (81) expr -> . IDENT MULASSIGN expr
    (82) expr -> . IDENT SUBASSIGN expr
    (83) expr -> . IDENT ADDASSIGN expr
    (84) expr -> . IDENT = expr
    NEW             shift and go to state 25
    STRING_LIT      shift and go to state 26
    CHAR_LIT        shift and go to state 27
    FLOAT_LIT       shift and go to state 28
    INT_LIT         shift and go to state 29
    FALSE           shift and go to state 30
    TRUE            shift and go to state 31
    BOOL_LIT        shift and go to state 32
    IDENT           shift and go to state 23
    (               shift and go to state 33
    DEC             shift and go to state 34
    INC             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    !               shift and go to state 38

    expr                           shift and go to state 88

state 49

    (81) expr -> IDENT MULASSIGN . expr
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING_LIT
    (47) expr -> . CHAR_LIT
    (48) expr -> . FLOAT_LIT
    (49) expr -> . INT_LIT
    (50) expr -> . FALSE
    (51) expr -> . TRUE
    (52) expr -> . BOOL_LIT
    (53) expr -> . IDENT . SIZE
    (54) expr -> . IDENT ( args )
    (55) expr -> . IDENT [ expr ]
    (56) expr -> . IDENT
    (57) expr -> . ( expr )
    (58) expr -> . expr DEC
    (59) expr -> . expr INC
    (60) expr -> . DEC expr
    (61) expr -> . INC expr
    (62) expr -> . PLUS expr
    (63) expr -> . MINUS expr
    (64) expr -> . ! expr
    (65) expr -> . expr MOD expr
    (66) expr -> . expr DIVIDE expr
    (67) expr -> . expr TIMES expr
    (68) expr -> . expr MINUS expr
    (69) expr -> . expr PLUS expr
    (70) expr -> . expr > expr
    (71) expr -> . expr GE expr
    (72) expr -> . expr < expr
    (73) expr -> . expr LE expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT [ expr ] = expr
    (79) expr -> . IDENT MODASSIGN expr
    (80) expr -> . IDENT DIVASSIGN expr
    (81) expr -> . IDENT MULASSIGN expr
    (82) expr -> . IDENT SUBASSIGN expr
    (83) expr -> . IDENT ADDASSIGN expr
    (84) expr -> . IDENT = expr
    NEW             shift and go to state 25
    STRING_LIT      shift and go to state 26
    CHAR_LIT        shift and go to state 27
    FLOAT_LIT       shift and go to state 28
    INT_LIT         shift and go to state 29
    FALSE           shift and go to state 30
    TRUE            shift and go to state 31
    BOOL_LIT        shift and go to state 32
    IDENT           shift and go to state 23
    (               shift and go to state 33
    DEC             shift and go to state 34
    INC             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    !               shift and go to state 38

    expr                           shift and go to state 89

state 50

    (82) expr -> IDENT SUBASSIGN . expr
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING_LIT
    (47) expr -> . CHAR_LIT
    (48) expr -> . FLOAT_LIT
    (49) expr -> . INT_LIT
    (50) expr -> . FALSE
    (51) expr -> . TRUE
    (52) expr -> . BOOL_LIT
    (53) expr -> . IDENT . SIZE
    (54) expr -> . IDENT ( args )
    (55) expr -> . IDENT [ expr ]
    (56) expr -> . IDENT
    (57) expr -> . ( expr )
    (58) expr -> . expr DEC
    (59) expr -> . expr INC
    (60) expr -> . DEC expr
    (61) expr -> . INC expr
    (62) expr -> . PLUS expr
    (63) expr -> . MINUS expr
    (64) expr -> . ! expr
    (65) expr -> . expr MOD expr
    (66) expr -> . expr DIVIDE expr
    (67) expr -> . expr TIMES expr
    (68) expr -> . expr MINUS expr
    (69) expr -> . expr PLUS expr
    (70) expr -> . expr > expr
    (71) expr -> . expr GE expr
    (72) expr -> . expr < expr
    (73) expr -> . expr LE expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT [ expr ] = expr
    (79) expr -> . IDENT MODASSIGN expr
    (80) expr -> . IDENT DIVASSIGN expr
    (81) expr -> . IDENT MULASSIGN expr
    (82) expr -> . IDENT SUBASSIGN expr
    (83) expr -> . IDENT ADDASSIGN expr
    (84) expr -> . IDENT = expr
    NEW             shift and go to state 25
    STRING_LIT      shift and go to state 26
    CHAR_LIT        shift and go to state 27
    FLOAT_LIT       shift and go to state 28
    INT_LIT         shift and go to state 29
    FALSE           shift and go to state 30
    TRUE            shift and go to state 31
    BOOL_LIT        shift and go to state 32
    IDENT           shift and go to state 23
    (               shift and go to state 33
    DEC             shift and go to state 34
    INC             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    !               shift and go to state 38

    expr                           shift and go to state 90

state 51

    (83) expr -> IDENT ADDASSIGN . expr
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING_LIT
    (47) expr -> . CHAR_LIT
    (48) expr -> . FLOAT_LIT
    (49) expr -> . INT_LIT
    (50) expr -> . FALSE
    (51) expr -> . TRUE
    (52) expr -> . BOOL_LIT
    (53) expr -> . IDENT . SIZE
    (54) expr -> . IDENT ( args )
    (55) expr -> . IDENT [ expr ]
    (56) expr -> . IDENT
    (57) expr -> . ( expr )
    (58) expr -> . expr DEC
    (59) expr -> . expr INC
    (60) expr -> . DEC expr
    (61) expr -> . INC expr
    (62) expr -> . PLUS expr
    (63) expr -> . MINUS expr
    (64) expr -> . ! expr
    (65) expr -> . expr MOD expr
    (66) expr -> . expr DIVIDE expr
    (67) expr -> . expr TIMES expr
    (68) expr -> . expr MINUS expr
    (69) expr -> . expr PLUS expr
    (70) expr -> . expr > expr
    (71) expr -> . expr GE expr
    (72) expr -> . expr < expr
    (73) expr -> . expr LE expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT [ expr ] = expr
    (79) expr -> . IDENT MODASSIGN expr
    (80) expr -> . IDENT DIVASSIGN expr
    (81) expr -> . IDENT MULASSIGN expr
    (82) expr -> . IDENT SUBASSIGN expr
    (83) expr -> . IDENT ADDASSIGN expr
    (84) expr -> . IDENT = expr
    NEW             shift and go to state 25
    STRING_LIT      shift and go to state 26
    CHAR_LIT        shift and go to state 27
    FLOAT_LIT       shift and go to state 28
    INT_LIT         shift and go to state 29
    FALSE           shift and go to state 30
    TRUE            shift and go to state 31
    BOOL_LIT        shift and go to state 32
    IDENT           shift and go to state 23
    (               shift and go to state 33
    DEC             shift and go to state 34
    INC             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    !               shift and go to state 38

    expr                           shift and go to state 91

state 52

    (6) var_decl -> type_spec IDENT [ expr ] . ;
    ;               shift and go to state 92


state 53

    (58) expr -> expr DEC .
    ]               reduce using rule 58 (expr -> expr DEC .)
    DEC             reduce using rule 58 (expr -> expr DEC .)
    INC             reduce using rule 58 (expr -> expr DEC .)
    MOD             reduce using rule 58 (expr -> expr DEC .)
    DIVIDE          reduce using rule 58 (expr -> expr DEC .)
    TIMES           reduce using rule 58 (expr -> expr DEC .)
    MINUS           reduce using rule 58 (expr -> expr DEC .)
    PLUS            reduce using rule 58 (expr -> expr DEC .)
    >               reduce using rule 58 (expr -> expr DEC .)
    GE              reduce using rule 58 (expr -> expr DEC .)
    <               reduce using rule 58 (expr -> expr DEC .)
    LE              reduce using rule 58 (expr -> expr DEC .)
    NE              reduce using rule 58 (expr -> expr DEC .)
    EQ              reduce using rule 58 (expr -> expr DEC .)
    AND             reduce using rule 58 (expr -> expr DEC .)
    OR              reduce using rule 58 (expr -> expr DEC .)
    ;               reduce using rule 58 (expr -> expr DEC .)
    )               reduce using rule 58 (expr -> expr DEC .)
    ,               reduce using rule 58 (expr -> expr DEC .)


state 54

    (59) expr -> expr INC .
    ]               reduce using rule 59 (expr -> expr INC .)
    DEC             reduce using rule 59 (expr -> expr INC .)
    INC             reduce using rule 59 (expr -> expr INC .)
    MOD             reduce using rule 59 (expr -> expr INC .)
    DIVIDE          reduce using rule 59 (expr -> expr INC .)
    TIMES           reduce using rule 59 (expr -> expr INC .)
    MINUS           reduce using rule 59 (expr -> expr INC .)
    PLUS            reduce using rule 59 (expr -> expr INC .)
    >               reduce using rule 59 (expr -> expr INC .)
    GE              reduce using rule 59 (expr -> expr INC .)
    <               reduce using rule 59 (expr -> expr INC .)
    LE              reduce using rule 59 (expr -> expr INC .)
    NE              reduce using rule 59 (expr -> expr INC .)
    EQ              reduce using rule 59 (expr -> expr INC .)
    AND             reduce using rule 59 (expr -> expr INC .)
    OR              reduce using rule 59 (expr -> expr INC .)
    ;               reduce using rule 59 (expr -> expr INC .)
    )               reduce using rule 59 (expr -> expr INC .)
    ,               reduce using rule 59 (expr -> expr INC .)


state 55

    (65) expr -> expr MOD . expr
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING_LIT
    (47) expr -> . CHAR_LIT
    (48) expr -> . FLOAT_LIT
    (49) expr -> . INT_LIT
    (50) expr -> . FALSE
    (51) expr -> . TRUE
    (52) expr -> . BOOL_LIT
    (53) expr -> . IDENT . SIZE
    (54) expr -> . IDENT ( args )
    (55) expr -> . IDENT [ expr ]
    (56) expr -> . IDENT
    (57) expr -> . ( expr )
    (58) expr -> . expr DEC
    (59) expr -> . expr INC
    (60) expr -> . DEC expr
    (61) expr -> . INC expr
    (62) expr -> . PLUS expr
    (63) expr -> . MINUS expr
    (64) expr -> . ! expr
    (65) expr -> . expr MOD expr
    (66) expr -> . expr DIVIDE expr
    (67) expr -> . expr TIMES expr
    (68) expr -> . expr MINUS expr
    (69) expr -> . expr PLUS expr
    (70) expr -> . expr > expr
    (71) expr -> . expr GE expr
    (72) expr -> . expr < expr
    (73) expr -> . expr LE expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT [ expr ] = expr
    (79) expr -> . IDENT MODASSIGN expr
    (80) expr -> . IDENT DIVASSIGN expr
    (81) expr -> . IDENT MULASSIGN expr
    (82) expr -> . IDENT SUBASSIGN expr
    (83) expr -> . IDENT ADDASSIGN expr
    (84) expr -> . IDENT = expr
    NEW             shift and go to state 25
    STRING_LIT      shift and go to state 26
    CHAR_LIT        shift and go to state 27
    FLOAT_LIT       shift and go to state 28
    INT_LIT         shift and go to state 29
    FALSE           shift and go to state 30
    TRUE            shift and go to state 31
    BOOL_LIT        shift and go to state 32
    IDENT           shift and go to state 23
    (               shift and go to state 33
    DEC             shift and go to state 34
    INC             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    !               shift and go to state 38

    expr                           shift and go to state 93

state 56

    (66) expr -> expr DIVIDE . expr
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING_LIT
    (47) expr -> . CHAR_LIT
    (48) expr -> . FLOAT_LIT
    (49) expr -> . INT_LIT
    (50) expr -> . FALSE
    (51) expr -> . TRUE
    (52) expr -> . BOOL_LIT
    (53) expr -> . IDENT . SIZE
    (54) expr -> . IDENT ( args )
    (55) expr -> . IDENT [ expr ]
    (56) expr -> . IDENT
    (57) expr -> . ( expr )
    (58) expr -> . expr DEC
    (59) expr -> . expr INC
    (60) expr -> . DEC expr
    (61) expr -> . INC expr
    (62) expr -> . PLUS expr
    (63) expr -> . MINUS expr
    (64) expr -> . ! expr
    (65) expr -> . expr MOD expr
    (66) expr -> . expr DIVIDE expr
    (67) expr -> . expr TIMES expr
    (68) expr -> . expr MINUS expr
    (69) expr -> . expr PLUS expr
    (70) expr -> . expr > expr
    (71) expr -> . expr GE expr
    (72) expr -> . expr < expr
    (73) expr -> . expr LE expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT [ expr ] = expr
    (79) expr -> . IDENT MODASSIGN expr
    (80) expr -> . IDENT DIVASSIGN expr
    (81) expr -> . IDENT MULASSIGN expr
    (82) expr -> . IDENT SUBASSIGN expr
    (83) expr -> . IDENT ADDASSIGN expr
    (84) expr -> . IDENT = expr
    NEW             shift and go to state 25
    STRING_LIT      shift and go to state 26
    CHAR_LIT        shift and go to state 27
    FLOAT_LIT       shift and go to state 28
    INT_LIT         shift and go to state 29
    FALSE           shift and go to state 30
    TRUE            shift and go to state 31
    BOOL_LIT        shift and go to state 32
    IDENT           shift and go to state 23
    (               shift and go to state 33
    DEC             shift and go to state 34
    INC             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    !               shift and go to state 38

    expr                           shift and go to state 94

state 57

    (67) expr -> expr TIMES . expr
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING_LIT
    (47) expr -> . CHAR_LIT
    (48) expr -> . FLOAT_LIT
    (49) expr -> . INT_LIT
    (50) expr -> . FALSE
    (51) expr -> . TRUE
    (52) expr -> . BOOL_LIT
    (53) expr -> . IDENT . SIZE
    (54) expr -> . IDENT ( args )
    (55) expr -> . IDENT [ expr ]
    (56) expr -> . IDENT
    (57) expr -> . ( expr )
    (58) expr -> . expr DEC
    (59) expr -> . expr INC
    (60) expr -> . DEC expr
    (61) expr -> . INC expr
    (62) expr -> . PLUS expr
    (63) expr -> . MINUS expr
    (64) expr -> . ! expr
    (65) expr -> . expr MOD expr
    (66) expr -> . expr DIVIDE expr
    (67) expr -> . expr TIMES expr
    (68) expr -> . expr MINUS expr
    (69) expr -> . expr PLUS expr
    (70) expr -> . expr > expr
    (71) expr -> . expr GE expr
    (72) expr -> . expr < expr
    (73) expr -> . expr LE expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT [ expr ] = expr
    (79) expr -> . IDENT MODASSIGN expr
    (80) expr -> . IDENT DIVASSIGN expr
    (81) expr -> . IDENT MULASSIGN expr
    (82) expr -> . IDENT SUBASSIGN expr
    (83) expr -> . IDENT ADDASSIGN expr
    (84) expr -> . IDENT = expr
    NEW             shift and go to state 25
    STRING_LIT      shift and go to state 26
    CHAR_LIT        shift and go to state 27
    FLOAT_LIT       shift and go to state 28
    INT_LIT         shift and go to state 29
    FALSE           shift and go to state 30
    TRUE            shift and go to state 31
    BOOL_LIT        shift and go to state 32
    IDENT           shift and go to state 23
    (               shift and go to state 33
    DEC             shift and go to state 34
    INC             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    !               shift and go to state 38

    expr                           shift and go to state 95

state 58

    (68) expr -> expr MINUS . expr
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING_LIT
    (47) expr -> . CHAR_LIT
    (48) expr -> . FLOAT_LIT
    (49) expr -> . INT_LIT
    (50) expr -> . FALSE
    (51) expr -> . TRUE
    (52) expr -> . BOOL_LIT
    (53) expr -> . IDENT . SIZE
    (54) expr -> . IDENT ( args )
    (55) expr -> . IDENT [ expr ]
    (56) expr -> . IDENT
    (57) expr -> . ( expr )
    (58) expr -> . expr DEC
    (59) expr -> . expr INC
    (60) expr -> . DEC expr
    (61) expr -> . INC expr
    (62) expr -> . PLUS expr
    (63) expr -> . MINUS expr
    (64) expr -> . ! expr
    (65) expr -> . expr MOD expr
    (66) expr -> . expr DIVIDE expr
    (67) expr -> . expr TIMES expr
    (68) expr -> . expr MINUS expr
    (69) expr -> . expr PLUS expr
    (70) expr -> . expr > expr
    (71) expr -> . expr GE expr
    (72) expr -> . expr < expr
    (73) expr -> . expr LE expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT [ expr ] = expr
    (79) expr -> . IDENT MODASSIGN expr
    (80) expr -> . IDENT DIVASSIGN expr
    (81) expr -> . IDENT MULASSIGN expr
    (82) expr -> . IDENT SUBASSIGN expr
    (83) expr -> . IDENT ADDASSIGN expr
    (84) expr -> . IDENT = expr
    NEW             shift and go to state 25
    STRING_LIT      shift and go to state 26
    CHAR_LIT        shift and go to state 27
    FLOAT_LIT       shift and go to state 28
    INT_LIT         shift and go to state 29
    FALSE           shift and go to state 30
    TRUE            shift and go to state 31
    BOOL_LIT        shift and go to state 32
    IDENT           shift and go to state 23
    (               shift and go to state 33
    DEC             shift and go to state 34
    INC             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    !               shift and go to state 38

    expr                           shift and go to state 96

state 59

    (69) expr -> expr PLUS . expr
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING_LIT
    (47) expr -> . CHAR_LIT
    (48) expr -> . FLOAT_LIT
    (49) expr -> . INT_LIT
    (50) expr -> . FALSE
    (51) expr -> . TRUE
    (52) expr -> . BOOL_LIT
    (53) expr -> . IDENT . SIZE
    (54) expr -> . IDENT ( args )
    (55) expr -> . IDENT [ expr ]
    (56) expr -> . IDENT
    (57) expr -> . ( expr )
    (58) expr -> . expr DEC
    (59) expr -> . expr INC
    (60) expr -> . DEC expr
    (61) expr -> . INC expr
    (62) expr -> . PLUS expr
    (63) expr -> . MINUS expr
    (64) expr -> . ! expr
    (65) expr -> . expr MOD expr
    (66) expr -> . expr DIVIDE expr
    (67) expr -> . expr TIMES expr
    (68) expr -> . expr MINUS expr
    (69) expr -> . expr PLUS expr
    (70) expr -> . expr > expr
    (71) expr -> . expr GE expr
    (72) expr -> . expr < expr
    (73) expr -> . expr LE expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT [ expr ] = expr
    (79) expr -> . IDENT MODASSIGN expr
    (80) expr -> . IDENT DIVASSIGN expr
    (81) expr -> . IDENT MULASSIGN expr
    (82) expr -> . IDENT SUBASSIGN expr
    (83) expr -> . IDENT ADDASSIGN expr
    (84) expr -> . IDENT = expr
    NEW             shift and go to state 25
    STRING_LIT      shift and go to state 26
    CHAR_LIT        shift and go to state 27
    FLOAT_LIT       shift and go to state 28
    INT_LIT         shift and go to state 29
    FALSE           shift and go to state 30
    TRUE            shift and go to state 31
    BOOL_LIT        shift and go to state 32
    IDENT           shift and go to state 23
    (               shift and go to state 33
    DEC             shift and go to state 34
    INC             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    !               shift and go to state 38

    expr                           shift and go to state 97

state 60

    (70) expr -> expr > . expr
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING_LIT
    (47) expr -> . CHAR_LIT
    (48) expr -> . FLOAT_LIT
    (49) expr -> . INT_LIT
    (50) expr -> . FALSE
    (51) expr -> . TRUE
    (52) expr -> . BOOL_LIT
    (53) expr -> . IDENT . SIZE
    (54) expr -> . IDENT ( args )
    (55) expr -> . IDENT [ expr ]
    (56) expr -> . IDENT
    (57) expr -> . ( expr )
    (58) expr -> . expr DEC
    (59) expr -> . expr INC
    (60) expr -> . DEC expr
    (61) expr -> . INC expr
    (62) expr -> . PLUS expr
    (63) expr -> . MINUS expr
    (64) expr -> . ! expr
    (65) expr -> . expr MOD expr
    (66) expr -> . expr DIVIDE expr
    (67) expr -> . expr TIMES expr
    (68) expr -> . expr MINUS expr
    (69) expr -> . expr PLUS expr
    (70) expr -> . expr > expr
    (71) expr -> . expr GE expr
    (72) expr -> . expr < expr
    (73) expr -> . expr LE expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT [ expr ] = expr
    (79) expr -> . IDENT MODASSIGN expr
    (80) expr -> . IDENT DIVASSIGN expr
    (81) expr -> . IDENT MULASSIGN expr
    (82) expr -> . IDENT SUBASSIGN expr
    (83) expr -> . IDENT ADDASSIGN expr
    (84) expr -> . IDENT = expr
    NEW             shift and go to state 25
    STRING_LIT      shift and go to state 26
    CHAR_LIT        shift and go to state 27
    FLOAT_LIT       shift and go to state 28
    INT_LIT         shift and go to state 29
    FALSE           shift and go to state 30
    TRUE            shift and go to state 31
    BOOL_LIT        shift and go to state 32
    IDENT           shift and go to state 23
    (               shift and go to state 33
    DEC             shift and go to state 34
    INC             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    !               shift and go to state 38

    expr                           shift and go to state 98

state 61

    (71) expr -> expr GE . expr
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING_LIT
    (47) expr -> . CHAR_LIT
    (48) expr -> . FLOAT_LIT
    (49) expr -> . INT_LIT
    (50) expr -> . FALSE
    (51) expr -> . TRUE
    (52) expr -> . BOOL_LIT
    (53) expr -> . IDENT . SIZE
    (54) expr -> . IDENT ( args )
    (55) expr -> . IDENT [ expr ]
    (56) expr -> . IDENT
    (57) expr -> . ( expr )
    (58) expr -> . expr DEC
    (59) expr -> . expr INC
    (60) expr -> . DEC expr
    (61) expr -> . INC expr
    (62) expr -> . PLUS expr
    (63) expr -> . MINUS expr
    (64) expr -> . ! expr
    (65) expr -> . expr MOD expr
    (66) expr -> . expr DIVIDE expr
    (67) expr -> . expr TIMES expr
    (68) expr -> . expr MINUS expr
    (69) expr -> . expr PLUS expr
    (70) expr -> . expr > expr
    (71) expr -> . expr GE expr
    (72) expr -> . expr < expr
    (73) expr -> . expr LE expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT [ expr ] = expr
    (79) expr -> . IDENT MODASSIGN expr
    (80) expr -> . IDENT DIVASSIGN expr
    (81) expr -> . IDENT MULASSIGN expr
    (82) expr -> . IDENT SUBASSIGN expr
    (83) expr -> . IDENT ADDASSIGN expr
    (84) expr -> . IDENT = expr
    NEW             shift and go to state 25
    STRING_LIT      shift and go to state 26
    CHAR_LIT        shift and go to state 27
    FLOAT_LIT       shift and go to state 28
    INT_LIT         shift and go to state 29
    FALSE           shift and go to state 30
    TRUE            shift and go to state 31
    BOOL_LIT        shift and go to state 32
    IDENT           shift and go to state 23
    (               shift and go to state 33
    DEC             shift and go to state 34
    INC             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    !               shift and go to state 38

    expr                           shift and go to state 99

state 62

    (72) expr -> expr < . expr
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING_LIT
    (47) expr -> . CHAR_LIT
    (48) expr -> . FLOAT_LIT
    (49) expr -> . INT_LIT
    (50) expr -> . FALSE
    (51) expr -> . TRUE
    (52) expr -> . BOOL_LIT
    (53) expr -> . IDENT . SIZE
    (54) expr -> . IDENT ( args )
    (55) expr -> . IDENT [ expr ]
    (56) expr -> . IDENT
    (57) expr -> . ( expr )
    (58) expr -> . expr DEC
    (59) expr -> . expr INC
    (60) expr -> . DEC expr
    (61) expr -> . INC expr
    (62) expr -> . PLUS expr
    (63) expr -> . MINUS expr
    (64) expr -> . ! expr
    (65) expr -> . expr MOD expr
    (66) expr -> . expr DIVIDE expr
    (67) expr -> . expr TIMES expr
    (68) expr -> . expr MINUS expr
    (69) expr -> . expr PLUS expr
    (70) expr -> . expr > expr
    (71) expr -> . expr GE expr
    (72) expr -> . expr < expr
    (73) expr -> . expr LE expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT [ expr ] = expr
    (79) expr -> . IDENT MODASSIGN expr
    (80) expr -> . IDENT DIVASSIGN expr
    (81) expr -> . IDENT MULASSIGN expr
    (82) expr -> . IDENT SUBASSIGN expr
    (83) expr -> . IDENT ADDASSIGN expr
    (84) expr -> . IDENT = expr
    NEW             shift and go to state 25
    STRING_LIT      shift and go to state 26
    CHAR_LIT        shift and go to state 27
    FLOAT_LIT       shift and go to state 28
    INT_LIT         shift and go to state 29
    FALSE           shift and go to state 30
    TRUE            shift and go to state 31
    BOOL_LIT        shift and go to state 32
    IDENT           shift and go to state 23
    (               shift and go to state 33
    DEC             shift and go to state 34
    INC             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    !               shift and go to state 38

    expr                           shift and go to state 100

state 63

    (73) expr -> expr LE . expr
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING_LIT
    (47) expr -> . CHAR_LIT
    (48) expr -> . FLOAT_LIT
    (49) expr -> . INT_LIT
    (50) expr -> . FALSE
    (51) expr -> . TRUE
    (52) expr -> . BOOL_LIT
    (53) expr -> . IDENT . SIZE
    (54) expr -> . IDENT ( args )
    (55) expr -> . IDENT [ expr ]
    (56) expr -> . IDENT
    (57) expr -> . ( expr )
    (58) expr -> . expr DEC
    (59) expr -> . expr INC
    (60) expr -> . DEC expr
    (61) expr -> . INC expr
    (62) expr -> . PLUS expr
    (63) expr -> . MINUS expr
    (64) expr -> . ! expr
    (65) expr -> . expr MOD expr
    (66) expr -> . expr DIVIDE expr
    (67) expr -> . expr TIMES expr
    (68) expr -> . expr MINUS expr
    (69) expr -> . expr PLUS expr
    (70) expr -> . expr > expr
    (71) expr -> . expr GE expr
    (72) expr -> . expr < expr
    (73) expr -> . expr LE expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT [ expr ] = expr
    (79) expr -> . IDENT MODASSIGN expr
    (80) expr -> . IDENT DIVASSIGN expr
    (81) expr -> . IDENT MULASSIGN expr
    (82) expr -> . IDENT SUBASSIGN expr
    (83) expr -> . IDENT ADDASSIGN expr
    (84) expr -> . IDENT = expr
    NEW             shift and go to state 25
    STRING_LIT      shift and go to state 26
    CHAR_LIT        shift and go to state 27
    FLOAT_LIT       shift and go to state 28
    INT_LIT         shift and go to state 29
    FALSE           shift and go to state 30
    TRUE            shift and go to state 31
    BOOL_LIT        shift and go to state 32
    IDENT           shift and go to state 23
    (               shift and go to state 33
    DEC             shift and go to state 34
    INC             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    !               shift and go to state 38

    expr                           shift and go to state 101

state 64

    (74) expr -> expr NE . expr
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING_LIT
    (47) expr -> . CHAR_LIT
    (48) expr -> . FLOAT_LIT
    (49) expr -> . INT_LIT
    (50) expr -> . FALSE
    (51) expr -> . TRUE
    (52) expr -> . BOOL_LIT
    (53) expr -> . IDENT . SIZE
    (54) expr -> . IDENT ( args )
    (55) expr -> . IDENT [ expr ]
    (56) expr -> . IDENT
    (57) expr -> . ( expr )
    (58) expr -> . expr DEC
    (59) expr -> . expr INC
    (60) expr -> . DEC expr
    (61) expr -> . INC expr
    (62) expr -> . PLUS expr
    (63) expr -> . MINUS expr
    (64) expr -> . ! expr
    (65) expr -> . expr MOD expr
    (66) expr -> . expr DIVIDE expr
    (67) expr -> . expr TIMES expr
    (68) expr -> . expr MINUS expr
    (69) expr -> . expr PLUS expr
    (70) expr -> . expr > expr
    (71) expr -> . expr GE expr
    (72) expr -> . expr < expr
    (73) expr -> . expr LE expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT [ expr ] = expr
    (79) expr -> . IDENT MODASSIGN expr
    (80) expr -> . IDENT DIVASSIGN expr
    (81) expr -> . IDENT MULASSIGN expr
    (82) expr -> . IDENT SUBASSIGN expr
    (83) expr -> . IDENT ADDASSIGN expr
    (84) expr -> . IDENT = expr
    NEW             shift and go to state 25
    STRING_LIT      shift and go to state 26
    CHAR_LIT        shift and go to state 27
    FLOAT_LIT       shift and go to state 28
    INT_LIT         shift and go to state 29
    FALSE           shift and go to state 30
    TRUE            shift and go to state 31
    BOOL_LIT        shift and go to state 32
    IDENT           shift and go to state 23
    (               shift and go to state 33
    DEC             shift and go to state 34
    INC             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    !               shift and go to state 38

    expr                           shift and go to state 102

state 65

    (75) expr -> expr EQ . expr
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING_LIT
    (47) expr -> . CHAR_LIT
    (48) expr -> . FLOAT_LIT
    (49) expr -> . INT_LIT
    (50) expr -> . FALSE
    (51) expr -> . TRUE
    (52) expr -> . BOOL_LIT
    (53) expr -> . IDENT . SIZE
    (54) expr -> . IDENT ( args )
    (55) expr -> . IDENT [ expr ]
    (56) expr -> . IDENT
    (57) expr -> . ( expr )
    (58) expr -> . expr DEC
    (59) expr -> . expr INC
    (60) expr -> . DEC expr
    (61) expr -> . INC expr
    (62) expr -> . PLUS expr
    (63) expr -> . MINUS expr
    (64) expr -> . ! expr
    (65) expr -> . expr MOD expr
    (66) expr -> . expr DIVIDE expr
    (67) expr -> . expr TIMES expr
    (68) expr -> . expr MINUS expr
    (69) expr -> . expr PLUS expr
    (70) expr -> . expr > expr
    (71) expr -> . expr GE expr
    (72) expr -> . expr < expr
    (73) expr -> . expr LE expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT [ expr ] = expr
    (79) expr -> . IDENT MODASSIGN expr
    (80) expr -> . IDENT DIVASSIGN expr
    (81) expr -> . IDENT MULASSIGN expr
    (82) expr -> . IDENT SUBASSIGN expr
    (83) expr -> . IDENT ADDASSIGN expr
    (84) expr -> . IDENT = expr
    NEW             shift and go to state 25
    STRING_LIT      shift and go to state 26
    CHAR_LIT        shift and go to state 27
    FLOAT_LIT       shift and go to state 28
    INT_LIT         shift and go to state 29
    FALSE           shift and go to state 30
    TRUE            shift and go to state 31
    BOOL_LIT        shift and go to state 32
    IDENT           shift and go to state 23
    (               shift and go to state 33
    DEC             shift and go to state 34
    INC             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    !               shift and go to state 38

    expr                           shift and go to state 103

state 66

    (76) expr -> expr AND . expr
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING_LIT
    (47) expr -> . CHAR_LIT
    (48) expr -> . FLOAT_LIT
    (49) expr -> . INT_LIT
    (50) expr -> . FALSE
    (51) expr -> . TRUE
    (52) expr -> . BOOL_LIT
    (53) expr -> . IDENT . SIZE
    (54) expr -> . IDENT ( args )
    (55) expr -> . IDENT [ expr ]
    (56) expr -> . IDENT
    (57) expr -> . ( expr )
    (58) expr -> . expr DEC
    (59) expr -> . expr INC
    (60) expr -> . DEC expr
    (61) expr -> . INC expr
    (62) expr -> . PLUS expr
    (63) expr -> . MINUS expr
    (64) expr -> . ! expr
    (65) expr -> . expr MOD expr
    (66) expr -> . expr DIVIDE expr
    (67) expr -> . expr TIMES expr
    (68) expr -> . expr MINUS expr
    (69) expr -> . expr PLUS expr
    (70) expr -> . expr > expr
    (71) expr -> . expr GE expr
    (72) expr -> . expr < expr
    (73) expr -> . expr LE expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT [ expr ] = expr
    (79) expr -> . IDENT MODASSIGN expr
    (80) expr -> . IDENT DIVASSIGN expr
    (81) expr -> . IDENT MULASSIGN expr
    (82) expr -> . IDENT SUBASSIGN expr
    (83) expr -> . IDENT ADDASSIGN expr
    (84) expr -> . IDENT = expr
    NEW             shift and go to state 25
    STRING_LIT      shift and go to state 26
    CHAR_LIT        shift and go to state 27
    FLOAT_LIT       shift and go to state 28
    INT_LIT         shift and go to state 29
    FALSE           shift and go to state 30
    TRUE            shift and go to state 31
    BOOL_LIT        shift and go to state 32
    IDENT           shift and go to state 23
    (               shift and go to state 33
    DEC             shift and go to state 34
    INC             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    !               shift and go to state 38

    expr                           shift and go to state 104

state 67

    (77) expr -> expr OR . expr
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING_LIT
    (47) expr -> . CHAR_LIT
    (48) expr -> . FLOAT_LIT
    (49) expr -> . INT_LIT
    (50) expr -> . FALSE
    (51) expr -> . TRUE
    (52) expr -> . BOOL_LIT
    (53) expr -> . IDENT . SIZE
    (54) expr -> . IDENT ( args )
    (55) expr -> . IDENT [ expr ]
    (56) expr -> . IDENT
    (57) expr -> . ( expr )
    (58) expr -> . expr DEC
    (59) expr -> . expr INC
    (60) expr -> . DEC expr
    (61) expr -> . INC expr
    (62) expr -> . PLUS expr
    (63) expr -> . MINUS expr
    (64) expr -> . ! expr
    (65) expr -> . expr MOD expr
    (66) expr -> . expr DIVIDE expr
    (67) expr -> . expr TIMES expr
    (68) expr -> . expr MINUS expr
    (69) expr -> . expr PLUS expr
    (70) expr -> . expr > expr
    (71) expr -> . expr GE expr
    (72) expr -> . expr < expr
    (73) expr -> . expr LE expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT [ expr ] = expr
    (79) expr -> . IDENT MODASSIGN expr
    (80) expr -> . IDENT DIVASSIGN expr
    (81) expr -> . IDENT MULASSIGN expr
    (82) expr -> . IDENT SUBASSIGN expr
    (83) expr -> . IDENT ADDASSIGN expr
    (84) expr -> . IDENT = expr
    NEW             shift and go to state 25
    STRING_LIT      shift and go to state 26
    CHAR_LIT        shift and go to state 27
    FLOAT_LIT       shift and go to state 28
    INT_LIT         shift and go to state 29
    FALSE           shift and go to state 30
    TRUE            shift and go to state 31
    BOOL_LIT        shift and go to state 32
    IDENT           shift and go to state 23
    (               shift and go to state 33
    DEC             shift and go to state 34
    INC             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    !               shift and go to state 38

    expr                           shift and go to state 105

state 68

    (45) expr -> NEW type_spec . [ expr ]
    [               shift and go to state 106


state 69

    (57) expr -> ( expr . )
    (58) expr -> expr . DEC
    (59) expr -> expr . INC
    (65) expr -> expr . MOD expr
    (66) expr -> expr . DIVIDE expr
    (67) expr -> expr . TIMES expr
    (68) expr -> expr . MINUS expr
    (69) expr -> expr . PLUS expr
    (70) expr -> expr . > expr
    (71) expr -> expr . GE expr
    (72) expr -> expr . < expr
    (73) expr -> expr . LE expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    )               shift and go to state 107
    DEC             shift and go to state 53
    INC             shift and go to state 54
    MOD             shift and go to state 55
    DIVIDE          shift and go to state 56
    TIMES           shift and go to state 57
    MINUS           shift and go to state 58
    PLUS            shift and go to state 59
    >               shift and go to state 60
    GE              shift and go to state 61
    <               shift and go to state 62
    LE              shift and go to state 63
    NE              shift and go to state 64
    EQ              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 70

    (60) expr -> DEC expr .
    (58) expr -> expr . DEC
    (59) expr -> expr . INC
    (65) expr -> expr . MOD expr
    (66) expr -> expr . DIVIDE expr
    (67) expr -> expr . TIMES expr
    (68) expr -> expr . MINUS expr
    (69) expr -> expr . PLUS expr
    (70) expr -> expr . > expr
    (71) expr -> expr . GE expr
    (72) expr -> expr . < expr
    (73) expr -> expr . LE expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    ]               reduce using rule 60 (expr -> DEC expr .)
    MOD             reduce using rule 60 (expr -> DEC expr .)
    DIVIDE          reduce using rule 60 (expr -> DEC expr .)
    TIMES           reduce using rule 60 (expr -> DEC expr .)
    MINUS           reduce using rule 60 (expr -> DEC expr .)
    PLUS            reduce using rule 60 (expr -> DEC expr .)
    >               reduce using rule 60 (expr -> DEC expr .)
    GE              reduce using rule 60 (expr -> DEC expr .)
    <               reduce using rule 60 (expr -> DEC expr .)
    LE              reduce using rule 60 (expr -> DEC expr .)
    NE              reduce using rule 60 (expr -> DEC expr .)
    EQ              reduce using rule 60 (expr -> DEC expr .)
    AND             reduce using rule 60 (expr -> DEC expr .)
    OR              reduce using rule 60 (expr -> DEC expr .)
    ;               reduce using rule 60 (expr -> DEC expr .)
    )               reduce using rule 60 (expr -> DEC expr .)
    ,               reduce using rule 60 (expr -> DEC expr .)
    DEC             shift and go to state 53
    INC             shift and go to state 54


state 71

    (61) expr -> INC expr .
    (58) expr -> expr . DEC
    (59) expr -> expr . INC
    (65) expr -> expr . MOD expr
    (66) expr -> expr . DIVIDE expr
    (67) expr -> expr . TIMES expr
    (68) expr -> expr . MINUS expr
    (69) expr -> expr . PLUS expr
    (70) expr -> expr . > expr
    (71) expr -> expr . GE expr
    (72) expr -> expr . < expr
    (73) expr -> expr . LE expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    ]               reduce using rule 61 (expr -> INC expr .)
    MOD             reduce using rule 61 (expr -> INC expr .)
    DIVIDE          reduce using rule 61 (expr -> INC expr .)
    TIMES           reduce using rule 61 (expr -> INC expr .)
    MINUS           reduce using rule 61 (expr -> INC expr .)
    PLUS            reduce using rule 61 (expr -> INC expr .)
    >               reduce using rule 61 (expr -> INC expr .)
    GE              reduce using rule 61 (expr -> INC expr .)
    <               reduce using rule 61 (expr -> INC expr .)
    LE              reduce using rule 61 (expr -> INC expr .)
    NE              reduce using rule 61 (expr -> INC expr .)
    EQ              reduce using rule 61 (expr -> INC expr .)
    AND             reduce using rule 61 (expr -> INC expr .)
    OR              reduce using rule 61 (expr -> INC expr .)
    ;               reduce using rule 61 (expr -> INC expr .)
    )               reduce using rule 61 (expr -> INC expr .)
    ,               reduce using rule 61 (expr -> INC expr .)
    DEC             shift and go to state 53
    INC             shift and go to state 54


state 72

    (62) expr -> PLUS expr .
    (58) expr -> expr . DEC
    (59) expr -> expr . INC
    (65) expr -> expr . MOD expr
    (66) expr -> expr . DIVIDE expr
    (67) expr -> expr . TIMES expr
    (68) expr -> expr . MINUS expr
    (69) expr -> expr . PLUS expr
    (70) expr -> expr . > expr
    (71) expr -> expr . GE expr
    (72) expr -> expr . < expr
    (73) expr -> expr . LE expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    ]               reduce using rule 62 (expr -> PLUS expr .)
    MOD             reduce using rule 62 (expr -> PLUS expr .)
    DIVIDE          reduce using rule 62 (expr -> PLUS expr .)
    TIMES           reduce using rule 62 (expr -> PLUS expr .)
    MINUS           reduce using rule 62 (expr -> PLUS expr .)
    PLUS            reduce using rule 62 (expr -> PLUS expr .)
    >               reduce using rule 62 (expr -> PLUS expr .)
    GE              reduce using rule 62 (expr -> PLUS expr .)
    <               reduce using rule 62 (expr -> PLUS expr .)
    LE              reduce using rule 62 (expr -> PLUS expr .)
    NE              reduce using rule 62 (expr -> PLUS expr .)
    EQ              reduce using rule 62 (expr -> PLUS expr .)
    AND             reduce using rule 62 (expr -> PLUS expr .)
    OR              reduce using rule 62 (expr -> PLUS expr .)
    ;               reduce using rule 62 (expr -> PLUS expr .)
    )               reduce using rule 62 (expr -> PLUS expr .)
    ,               reduce using rule 62 (expr -> PLUS expr .)
    DEC             shift and go to state 53
    INC             shift and go to state 54


state 73

    (63) expr -> MINUS expr .
    (58) expr -> expr . DEC
    (59) expr -> expr . INC
    (65) expr -> expr . MOD expr
    (66) expr -> expr . DIVIDE expr
    (67) expr -> expr . TIMES expr
    (68) expr -> expr . MINUS expr
    (69) expr -> expr . PLUS expr
    (70) expr -> expr . > expr
    (71) expr -> expr . GE expr
    (72) expr -> expr . < expr
    (73) expr -> expr . LE expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    ]               reduce using rule 63 (expr -> MINUS expr .)
    MOD             reduce using rule 63 (expr -> MINUS expr .)
    DIVIDE          reduce using rule 63 (expr -> MINUS expr .)
    TIMES           reduce using rule 63 (expr -> MINUS expr .)
    MINUS           reduce using rule 63 (expr -> MINUS expr .)
    PLUS            reduce using rule 63 (expr -> MINUS expr .)
    >               reduce using rule 63 (expr -> MINUS expr .)
    GE              reduce using rule 63 (expr -> MINUS expr .)
    <               reduce using rule 63 (expr -> MINUS expr .)
    LE              reduce using rule 63 (expr -> MINUS expr .)
    NE              reduce using rule 63 (expr -> MINUS expr .)
    EQ              reduce using rule 63 (expr -> MINUS expr .)
    AND             reduce using rule 63 (expr -> MINUS expr .)
    OR              reduce using rule 63 (expr -> MINUS expr .)
    ;               reduce using rule 63 (expr -> MINUS expr .)
    )               reduce using rule 63 (expr -> MINUS expr .)
    ,               reduce using rule 63 (expr -> MINUS expr .)
    DEC             shift and go to state 53
    INC             shift and go to state 54


state 74

    (64) expr -> ! expr .
    (58) expr -> expr . DEC
    (59) expr -> expr . INC
    (65) expr -> expr . MOD expr
    (66) expr -> expr . DIVIDE expr
    (67) expr -> expr . TIMES expr
    (68) expr -> expr . MINUS expr
    (69) expr -> expr . PLUS expr
    (70) expr -> expr . > expr
    (71) expr -> expr . GE expr
    (72) expr -> expr . < expr
    (73) expr -> expr . LE expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    ]               reduce using rule 64 (expr -> ! expr .)
    MOD             reduce using rule 64 (expr -> ! expr .)
    DIVIDE          reduce using rule 64 (expr -> ! expr .)
    TIMES           reduce using rule 64 (expr -> ! expr .)
    MINUS           reduce using rule 64 (expr -> ! expr .)
    PLUS            reduce using rule 64 (expr -> ! expr .)
    >               reduce using rule 64 (expr -> ! expr .)
    GE              reduce using rule 64 (expr -> ! expr .)
    <               reduce using rule 64 (expr -> ! expr .)
    LE              reduce using rule 64 (expr -> ! expr .)
    NE              reduce using rule 64 (expr -> ! expr .)
    EQ              reduce using rule 64 (expr -> ! expr .)
    AND             reduce using rule 64 (expr -> ! expr .)
    OR              reduce using rule 64 (expr -> ! expr .)
    ;               reduce using rule 64 (expr -> ! expr .)
    )               reduce using rule 64 (expr -> ! expr .)
    ,               reduce using rule 64 (expr -> ! expr .)
    DEC             shift and go to state 53
    INC             shift and go to state 54


state 75

    (7) var_decl -> type_spec IDENT = expr ; .
    CHAR            reduce using rule 7 (var_decl -> type_spec IDENT = expr ; .)
    FLOAT           reduce using rule 7 (var_decl -> type_spec IDENT = expr ; .)
    INT             reduce using rule 7 (var_decl -> type_spec IDENT = expr ; .)
    BOOL            reduce using rule 7 (var_decl -> type_spec IDENT = expr ; .)
    VOID            reduce using rule 7 (var_decl -> type_spec IDENT = expr ; .)
    $end            reduce using rule 7 (var_decl -> type_spec IDENT = expr ; .)


state 76

    (19) param -> type_spec IDENT [ . ]
    ]               shift and go to state 108


state 77

    (14) fun_decl -> type_spec IDENT ( params ) compound_stmt .
    CHAR            reduce using rule 14 (fun_decl -> type_spec IDENT ( params ) compound_stmt .)
    FLOAT           reduce using rule 14 (fun_decl -> type_spec IDENT ( params ) compound_stmt .)
    INT             reduce using rule 14 (fun_decl -> type_spec IDENT ( params ) compound_stmt .)
    BOOL            reduce using rule 14 (fun_decl -> type_spec IDENT ( params ) compound_stmt .)
    VOID            reduce using rule 14 (fun_decl -> type_spec IDENT ( params ) compound_stmt .)
    $end            reduce using rule 14 (fun_decl -> type_spec IDENT ( params ) compound_stmt .)


state 78

    (21) compound_stmt -> { . local_decls stmt_list }
    (22) local_decls -> . empty
    (23) local_decls -> . local_decls local_decl
    (89) empty -> .
    CHAR            reduce using rule 89 (empty -> .)
    FLOAT           reduce using rule 89 (empty -> .)
    INT             reduce using rule 89 (empty -> .)
    BOOL            reduce using rule 89 (empty -> .)
    VOID            reduce using rule 89 (empty -> .)
    }               reduce using rule 89 (empty -> .)
    BREAK           reduce using rule 89 (empty -> .)
    RETURN          reduce using rule 89 (empty -> .)
    FOR             reduce using rule 89 (empty -> .)
    WHILE           reduce using rule 89 (empty -> .)
    IF              reduce using rule 89 (empty -> .)
    {               reduce using rule 89 (empty -> .)
    ;               reduce using rule 89 (empty -> .)
    NEW             reduce using rule 89 (empty -> .)
    STRING_LIT      reduce using rule 89 (empty -> .)
    CHAR_LIT        reduce using rule 89 (empty -> .)
    FLOAT_LIT       reduce using rule 89 (empty -> .)
    INT_LIT         reduce using rule 89 (empty -> .)
    FALSE           reduce using rule 89 (empty -> .)
    TRUE            reduce using rule 89 (empty -> .)
    BOOL_LIT        reduce using rule 89 (empty -> .)
    IDENT           reduce using rule 89 (empty -> .)
    (               reduce using rule 89 (empty -> .)
    DEC             reduce using rule 89 (empty -> .)
    INC             reduce using rule 89 (empty -> .)
    PLUS            reduce using rule 89 (empty -> .)
    MINUS           reduce using rule 89 (empty -> .)
    !               reduce using rule 89 (empty -> .)

    local_decls                    shift and go to state 109
    empty                          shift and go to state 110

state 79

    (18) param_list -> param_list , param .
    ,               reduce using rule 18 (param_list -> param_list , param .)
    )               reduce using rule 18 (param_list -> param_list , param .)


state 80

    (53) expr -> IDENT . SIZE .
    ]               reduce using rule 53 (expr -> IDENT . SIZE .)
    DEC             reduce using rule 53 (expr -> IDENT . SIZE .)
    INC             reduce using rule 53 (expr -> IDENT . SIZE .)
    MOD             reduce using rule 53 (expr -> IDENT . SIZE .)
    DIVIDE          reduce using rule 53 (expr -> IDENT . SIZE .)
    TIMES           reduce using rule 53 (expr -> IDENT . SIZE .)
    MINUS           reduce using rule 53 (expr -> IDENT . SIZE .)
    PLUS            reduce using rule 53 (expr -> IDENT . SIZE .)
    >               reduce using rule 53 (expr -> IDENT . SIZE .)
    GE              reduce using rule 53 (expr -> IDENT . SIZE .)
    <               reduce using rule 53 (expr -> IDENT . SIZE .)
    LE              reduce using rule 53 (expr -> IDENT . SIZE .)
    NE              reduce using rule 53 (expr -> IDENT . SIZE .)
    EQ              reduce using rule 53 (expr -> IDENT . SIZE .)
    AND             reduce using rule 53 (expr -> IDENT . SIZE .)
    OR              reduce using rule 53 (expr -> IDENT . SIZE .)
    ;               reduce using rule 53 (expr -> IDENT . SIZE .)
    )               reduce using rule 53 (expr -> IDENT . SIZE .)
    ,               reduce using rule 53 (expr -> IDENT . SIZE .)


state 81

    (54) expr -> IDENT ( args . )
    )               shift and go to state 111


state 82

    (87) args -> empty .
    )               reduce using rule 87 (args -> empty .)
    ;               reduce using rule 87 (args -> empty .)


state 83

    (88) args -> arg_list .
    (86) arg_list -> arg_list . , expr
    )               reduce using rule 88 (args -> arg_list .)
    ;               reduce using rule 88 (args -> arg_list .)
    ,               shift and go to state 112


state 84

    (85) arg_list -> expr .
    (58) expr -> expr . DEC
    (59) expr -> expr . INC
    (65) expr -> expr . MOD expr
    (66) expr -> expr . DIVIDE expr
    (67) expr -> expr . TIMES expr
    (68) expr -> expr . MINUS expr
    (69) expr -> expr . PLUS expr
    (70) expr -> expr . > expr
    (71) expr -> expr . GE expr
    (72) expr -> expr . < expr
    (73) expr -> expr . LE expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    ,               reduce using rule 85 (arg_list -> expr .)
    )               reduce using rule 85 (arg_list -> expr .)
    ;               reduce using rule 85 (arg_list -> expr .)
    DEC             shift and go to state 53
    INC             shift and go to state 54
    MOD             shift and go to state 55
    DIVIDE          shift and go to state 56
    TIMES           shift and go to state 57
    MINUS           shift and go to state 58
    PLUS            shift and go to state 59
    >               shift and go to state 60
    GE              shift and go to state 61
    <               shift and go to state 62
    LE              shift and go to state 63
    NE              shift and go to state 64
    EQ              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 85

    (55) expr -> IDENT [ expr . ]
    (78) expr -> IDENT [ expr . ] = expr
    (58) expr -> expr . DEC
    (59) expr -> expr . INC
    (65) expr -> expr . MOD expr
    (66) expr -> expr . DIVIDE expr
    (67) expr -> expr . TIMES expr
    (68) expr -> expr . MINUS expr
    (69) expr -> expr . PLUS expr
    (70) expr -> expr . > expr
    (71) expr -> expr . GE expr
    (72) expr -> expr . < expr
    (73) expr -> expr . LE expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    ]               shift and go to state 113
    DEC             shift and go to state 53
    INC             shift and go to state 54
    MOD             shift and go to state 55
    DIVIDE          shift and go to state 56
    TIMES           shift and go to state 57
    MINUS           shift and go to state 58
    PLUS            shift and go to state 59
    >               shift and go to state 60
    GE              shift and go to state 61
    <               shift and go to state 62
    LE              shift and go to state 63
    NE              shift and go to state 64
    EQ              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 86

    (84) expr -> IDENT = expr .
    (58) expr -> expr . DEC
    (59) expr -> expr . INC
    (65) expr -> expr . MOD expr
    (66) expr -> expr . DIVIDE expr
    (67) expr -> expr . TIMES expr
    (68) expr -> expr . MINUS expr
    (69) expr -> expr . PLUS expr
    (70) expr -> expr . > expr
    (71) expr -> expr . GE expr
    (72) expr -> expr . < expr
    (73) expr -> expr . LE expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    ]               reduce using rule 84 (expr -> IDENT = expr .)
    ;               reduce using rule 84 (expr -> IDENT = expr .)
    )               reduce using rule 84 (expr -> IDENT = expr .)
    ,               reduce using rule 84 (expr -> IDENT = expr .)
    DEC             shift and go to state 53
    INC             shift and go to state 54
    MOD             shift and go to state 55
    DIVIDE          shift and go to state 56
    TIMES           shift and go to state 57
    MINUS           shift and go to state 58
    PLUS            shift and go to state 59
    >               shift and go to state 60
    GE              shift and go to state 61
    <               shift and go to state 62
    LE              shift and go to state 63
    NE              shift and go to state 64
    EQ              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 87

    (79) expr -> IDENT MODASSIGN expr .
    (58) expr -> expr . DEC
    (59) expr -> expr . INC
    (65) expr -> expr . MOD expr
    (66) expr -> expr . DIVIDE expr
    (67) expr -> expr . TIMES expr
    (68) expr -> expr . MINUS expr
    (69) expr -> expr . PLUS expr
    (70) expr -> expr . > expr
    (71) expr -> expr . GE expr
    (72) expr -> expr . < expr
    (73) expr -> expr . LE expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    ]               reduce using rule 79 (expr -> IDENT MODASSIGN expr .)
    ;               reduce using rule 79 (expr -> IDENT MODASSIGN expr .)
    )               reduce using rule 79 (expr -> IDENT MODASSIGN expr .)
    ,               reduce using rule 79 (expr -> IDENT MODASSIGN expr .)
    DEC             shift and go to state 53
    INC             shift and go to state 54
    MOD             shift and go to state 55
    DIVIDE          shift and go to state 56
    TIMES           shift and go to state 57
    MINUS           shift and go to state 58
    PLUS            shift and go to state 59
    >               shift and go to state 60
    GE              shift and go to state 61
    <               shift and go to state 62
    LE              shift and go to state 63
    NE              shift and go to state 64
    EQ              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 88

    (80) expr -> IDENT DIVASSIGN expr .
    (58) expr -> expr . DEC
    (59) expr -> expr . INC
    (65) expr -> expr . MOD expr
    (66) expr -> expr . DIVIDE expr
    (67) expr -> expr . TIMES expr
    (68) expr -> expr . MINUS expr
    (69) expr -> expr . PLUS expr
    (70) expr -> expr . > expr
    (71) expr -> expr . GE expr
    (72) expr -> expr . < expr
    (73) expr -> expr . LE expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    ]               reduce using rule 80 (expr -> IDENT DIVASSIGN expr .)
    ;               reduce using rule 80 (expr -> IDENT DIVASSIGN expr .)
    )               reduce using rule 80 (expr -> IDENT DIVASSIGN expr .)
    ,               reduce using rule 80 (expr -> IDENT DIVASSIGN expr .)
    DEC             shift and go to state 53
    INC             shift and go to state 54
    MOD             shift and go to state 55
    DIVIDE          shift and go to state 56
    TIMES           shift and go to state 57
    MINUS           shift and go to state 58
    PLUS            shift and go to state 59
    >               shift and go to state 60
    GE              shift and go to state 61
    <               shift and go to state 62
    LE              shift and go to state 63
    NE              shift and go to state 64
    EQ              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 89

    (81) expr -> IDENT MULASSIGN expr .
    (58) expr -> expr . DEC
    (59) expr -> expr . INC
    (65) expr -> expr . MOD expr
    (66) expr -> expr . DIVIDE expr
    (67) expr -> expr . TIMES expr
    (68) expr -> expr . MINUS expr
    (69) expr -> expr . PLUS expr
    (70) expr -> expr . > expr
    (71) expr -> expr . GE expr
    (72) expr -> expr . < expr
    (73) expr -> expr . LE expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    ]               reduce using rule 81 (expr -> IDENT MULASSIGN expr .)
    ;               reduce using rule 81 (expr -> IDENT MULASSIGN expr .)
    )               reduce using rule 81 (expr -> IDENT MULASSIGN expr .)
    ,               reduce using rule 81 (expr -> IDENT MULASSIGN expr .)
    DEC             shift and go to state 53
    INC             shift and go to state 54
    MOD             shift and go to state 55
    DIVIDE          shift and go to state 56
    TIMES           shift and go to state 57
    MINUS           shift and go to state 58
    PLUS            shift and go to state 59
    >               shift and go to state 60
    GE              shift and go to state 61
    <               shift and go to state 62
    LE              shift and go to state 63
    NE              shift and go to state 64
    EQ              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 90

    (82) expr -> IDENT SUBASSIGN expr .
    (58) expr -> expr . DEC
    (59) expr -> expr . INC
    (65) expr -> expr . MOD expr
    (66) expr -> expr . DIVIDE expr
    (67) expr -> expr . TIMES expr
    (68) expr -> expr . MINUS expr
    (69) expr -> expr . PLUS expr
    (70) expr -> expr . > expr
    (71) expr -> expr . GE expr
    (72) expr -> expr . < expr
    (73) expr -> expr . LE expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    ]               reduce using rule 82 (expr -> IDENT SUBASSIGN expr .)
    ;               reduce using rule 82 (expr -> IDENT SUBASSIGN expr .)
    )               reduce using rule 82 (expr -> IDENT SUBASSIGN expr .)
    ,               reduce using rule 82 (expr -> IDENT SUBASSIGN expr .)
    DEC             shift and go to state 53
    INC             shift and go to state 54
    MOD             shift and go to state 55
    DIVIDE          shift and go to state 56
    TIMES           shift and go to state 57
    MINUS           shift and go to state 58
    PLUS            shift and go to state 59
    >               shift and go to state 60
    GE              shift and go to state 61
    <               shift and go to state 62
    LE              shift and go to state 63
    NE              shift and go to state 64
    EQ              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 91

    (83) expr -> IDENT ADDASSIGN expr .
    (58) expr -> expr . DEC
    (59) expr -> expr . INC
    (65) expr -> expr . MOD expr
    (66) expr -> expr . DIVIDE expr
    (67) expr -> expr . TIMES expr
    (68) expr -> expr . MINUS expr
    (69) expr -> expr . PLUS expr
    (70) expr -> expr . > expr
    (71) expr -> expr . GE expr
    (72) expr -> expr . < expr
    (73) expr -> expr . LE expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    ]               reduce using rule 83 (expr -> IDENT ADDASSIGN expr .)
    ;               reduce using rule 83 (expr -> IDENT ADDASSIGN expr .)
    )               reduce using rule 83 (expr -> IDENT ADDASSIGN expr .)
    ,               reduce using rule 83 (expr -> IDENT ADDASSIGN expr .)
    DEC             shift and go to state 53
    INC             shift and go to state 54
    MOD             shift and go to state 55
    DIVIDE          shift and go to state 56
    TIMES           shift and go to state 57
    MINUS           shift and go to state 58
    PLUS            shift and go to state 59
    >               shift and go to state 60
    GE              shift and go to state 61
    <               shift and go to state 62
    LE              shift and go to state 63
    NE              shift and go to state 64
    EQ              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 92

    (6) var_decl -> type_spec IDENT [ expr ] ; .
    CHAR            reduce using rule 6 (var_decl -> type_spec IDENT [ expr ] ; .)
    FLOAT           reduce using rule 6 (var_decl -> type_spec IDENT [ expr ] ; .)
    INT             reduce using rule 6 (var_decl -> type_spec IDENT [ expr ] ; .)
    BOOL            reduce using rule 6 (var_decl -> type_spec IDENT [ expr ] ; .)
    VOID            reduce using rule 6 (var_decl -> type_spec IDENT [ expr ] ; .)
    $end            reduce using rule 6 (var_decl -> type_spec IDENT [ expr ] ; .)


state 93

    (65) expr -> expr MOD expr .
    (58) expr -> expr . DEC
    (59) expr -> expr . INC
    (65) expr -> expr . MOD expr
    (66) expr -> expr . DIVIDE expr
    (67) expr -> expr . TIMES expr
    (68) expr -> expr . MINUS expr
    (69) expr -> expr . PLUS expr
    (70) expr -> expr . > expr
    (71) expr -> expr . GE expr
    (72) expr -> expr . < expr
    (73) expr -> expr . LE expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    ]               reduce using rule 65 (expr -> expr MOD expr .)
    MOD             reduce using rule 65 (expr -> expr MOD expr .)
    DIVIDE          reduce using rule 65 (expr -> expr MOD expr .)
    TIMES           reduce using rule 65 (expr -> expr MOD expr .)
    MINUS           reduce using rule 65 (expr -> expr MOD expr .)
    PLUS            reduce using rule 65 (expr -> expr MOD expr .)
    >               reduce using rule 65 (expr -> expr MOD expr .)
    GE              reduce using rule 65 (expr -> expr MOD expr .)
    <               reduce using rule 65 (expr -> expr MOD expr .)
    LE              reduce using rule 65 (expr -> expr MOD expr .)
    NE              reduce using rule 65 (expr -> expr MOD expr .)
    EQ              reduce using rule 65 (expr -> expr MOD expr .)
    AND             reduce using rule 65 (expr -> expr MOD expr .)
    OR              reduce using rule 65 (expr -> expr MOD expr .)
    ;               reduce using rule 65 (expr -> expr MOD expr .)
    )               reduce using rule 65 (expr -> expr MOD expr .)
    ,               reduce using rule 65 (expr -> expr MOD expr .)
    DEC             shift and go to state 53
    INC             shift and go to state 54


state 94

    (66) expr -> expr DIVIDE expr .
    (58) expr -> expr . DEC
    (59) expr -> expr . INC
    (65) expr -> expr . MOD expr
    (66) expr -> expr . DIVIDE expr
    (67) expr -> expr . TIMES expr
    (68) expr -> expr . MINUS expr
    (69) expr -> expr . PLUS expr
    (70) expr -> expr . > expr
    (71) expr -> expr . GE expr
    (72) expr -> expr . < expr
    (73) expr -> expr . LE expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    ]               reduce using rule 66 (expr -> expr DIVIDE expr .)
    MOD             reduce using rule 66 (expr -> expr DIVIDE expr .)
    DIVIDE          reduce using rule 66 (expr -> expr DIVIDE expr .)
    TIMES           reduce using rule 66 (expr -> expr DIVIDE expr .)
    MINUS           reduce using rule 66 (expr -> expr DIVIDE expr .)
    PLUS            reduce using rule 66 (expr -> expr DIVIDE expr .)
    >               reduce using rule 66 (expr -> expr DIVIDE expr .)
    GE              reduce using rule 66 (expr -> expr DIVIDE expr .)
    <               reduce using rule 66 (expr -> expr DIVIDE expr .)
    LE              reduce using rule 66 (expr -> expr DIVIDE expr .)
    NE              reduce using rule 66 (expr -> expr DIVIDE expr .)
    EQ              reduce using rule 66 (expr -> expr DIVIDE expr .)
    AND             reduce using rule 66 (expr -> expr DIVIDE expr .)
    OR              reduce using rule 66 (expr -> expr DIVIDE expr .)
    ;               reduce using rule 66 (expr -> expr DIVIDE expr .)
    )               reduce using rule 66 (expr -> expr DIVIDE expr .)
    ,               reduce using rule 66 (expr -> expr DIVIDE expr .)
    DEC             shift and go to state 53
    INC             shift and go to state 54


state 95

    (67) expr -> expr TIMES expr .
    (58) expr -> expr . DEC
    (59) expr -> expr . INC
    (65) expr -> expr . MOD expr
    (66) expr -> expr . DIVIDE expr
    (67) expr -> expr . TIMES expr
    (68) expr -> expr . MINUS expr
    (69) expr -> expr . PLUS expr
    (70) expr -> expr . > expr
    (71) expr -> expr . GE expr
    (72) expr -> expr . < expr
    (73) expr -> expr . LE expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    ]               reduce using rule 67 (expr -> expr TIMES expr .)
    MOD             reduce using rule 67 (expr -> expr TIMES expr .)
    DIVIDE          reduce using rule 67 (expr -> expr TIMES expr .)
    TIMES           reduce using rule 67 (expr -> expr TIMES expr .)
    MINUS           reduce using rule 67 (expr -> expr TIMES expr .)
    PLUS            reduce using rule 67 (expr -> expr TIMES expr .)
    >               reduce using rule 67 (expr -> expr TIMES expr .)
    GE              reduce using rule 67 (expr -> expr TIMES expr .)
    <               reduce using rule 67 (expr -> expr TIMES expr .)
    LE              reduce using rule 67 (expr -> expr TIMES expr .)
    NE              reduce using rule 67 (expr -> expr TIMES expr .)
    EQ              reduce using rule 67 (expr -> expr TIMES expr .)
    AND             reduce using rule 67 (expr -> expr TIMES expr .)
    OR              reduce using rule 67 (expr -> expr TIMES expr .)
    ;               reduce using rule 67 (expr -> expr TIMES expr .)
    )               reduce using rule 67 (expr -> expr TIMES expr .)
    ,               reduce using rule 67 (expr -> expr TIMES expr .)
    DEC             shift and go to state 53
    INC             shift and go to state 54


state 96

    (68) expr -> expr MINUS expr .
    (58) expr -> expr . DEC
    (59) expr -> expr . INC
    (65) expr -> expr . MOD expr
    (66) expr -> expr . DIVIDE expr
    (67) expr -> expr . TIMES expr
    (68) expr -> expr . MINUS expr
    (69) expr -> expr . PLUS expr
    (70) expr -> expr . > expr
    (71) expr -> expr . GE expr
    (72) expr -> expr . < expr
    (73) expr -> expr . LE expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    ]               reduce using rule 68 (expr -> expr MINUS expr .)
    MINUS           reduce using rule 68 (expr -> expr MINUS expr .)
    PLUS            reduce using rule 68 (expr -> expr MINUS expr .)
    >               reduce using rule 68 (expr -> expr MINUS expr .)
    GE              reduce using rule 68 (expr -> expr MINUS expr .)
    <               reduce using rule 68 (expr -> expr MINUS expr .)
    LE              reduce using rule 68 (expr -> expr MINUS expr .)
    NE              reduce using rule 68 (expr -> expr MINUS expr .)
    EQ              reduce using rule 68 (expr -> expr MINUS expr .)
    AND             reduce using rule 68 (expr -> expr MINUS expr .)
    OR              reduce using rule 68 (expr -> expr MINUS expr .)
    ;               reduce using rule 68 (expr -> expr MINUS expr .)
    )               reduce using rule 68 (expr -> expr MINUS expr .)
    ,               reduce using rule 68 (expr -> expr MINUS expr .)
    DEC             shift and go to state 53
    INC             shift and go to state 54
    MOD             shift and go to state 55
    DIVIDE          shift and go to state 56
    TIMES           shift and go to state 57


state 97

    (69) expr -> expr PLUS expr .
    (58) expr -> expr . DEC
    (59) expr -> expr . INC
    (65) expr -> expr . MOD expr
    (66) expr -> expr . DIVIDE expr
    (67) expr -> expr . TIMES expr
    (68) expr -> expr . MINUS expr
    (69) expr -> expr . PLUS expr
    (70) expr -> expr . > expr
    (71) expr -> expr . GE expr
    (72) expr -> expr . < expr
    (73) expr -> expr . LE expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    ]               reduce using rule 69 (expr -> expr PLUS expr .)
    MINUS           reduce using rule 69 (expr -> expr PLUS expr .)
    PLUS            reduce using rule 69 (expr -> expr PLUS expr .)
    >               reduce using rule 69 (expr -> expr PLUS expr .)
    GE              reduce using rule 69 (expr -> expr PLUS expr .)
    <               reduce using rule 69 (expr -> expr PLUS expr .)
    LE              reduce using rule 69 (expr -> expr PLUS expr .)
    NE              reduce using rule 69 (expr -> expr PLUS expr .)
    EQ              reduce using rule 69 (expr -> expr PLUS expr .)
    AND             reduce using rule 69 (expr -> expr PLUS expr .)
    OR              reduce using rule 69 (expr -> expr PLUS expr .)
    ;               reduce using rule 69 (expr -> expr PLUS expr .)
    )               reduce using rule 69 (expr -> expr PLUS expr .)
    ,               reduce using rule 69 (expr -> expr PLUS expr .)
    DEC             shift and go to state 53
    INC             shift and go to state 54
    MOD             shift and go to state 55
    DIVIDE          shift and go to state 56
    TIMES           shift and go to state 57


state 98

    (70) expr -> expr > expr .
    (58) expr -> expr . DEC
    (59) expr -> expr . INC
    (65) expr -> expr . MOD expr
    (66) expr -> expr . DIVIDE expr
    (67) expr -> expr . TIMES expr
    (68) expr -> expr . MINUS expr
    (69) expr -> expr . PLUS expr
    (70) expr -> expr . > expr
    (71) expr -> expr . GE expr
    (72) expr -> expr . < expr
    (73) expr -> expr . LE expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    ]               reduce using rule 70 (expr -> expr > expr .)
    >               reduce using rule 70 (expr -> expr > expr .)
    GE              reduce using rule 70 (expr -> expr > expr .)
    <               reduce using rule 70 (expr -> expr > expr .)
    LE              reduce using rule 70 (expr -> expr > expr .)
    NE              reduce using rule 70 (expr -> expr > expr .)
    EQ              reduce using rule 70 (expr -> expr > expr .)
    AND             reduce using rule 70 (expr -> expr > expr .)
    OR              reduce using rule 70 (expr -> expr > expr .)
    ;               reduce using rule 70 (expr -> expr > expr .)
    )               reduce using rule 70 (expr -> expr > expr .)
    ,               reduce using rule 70 (expr -> expr > expr .)
    DEC             shift and go to state 53
    INC             shift and go to state 54
    MOD             shift and go to state 55
    DIVIDE          shift and go to state 56
    TIMES           shift and go to state 57
    MINUS           shift and go to state 58
    PLUS            shift and go to state 59


state 99

    (71) expr -> expr GE expr .
    (58) expr -> expr . DEC
    (59) expr -> expr . INC
    (65) expr -> expr . MOD expr
    (66) expr -> expr . DIVIDE expr
    (67) expr -> expr . TIMES expr
    (68) expr -> expr . MINUS expr
    (69) expr -> expr . PLUS expr
    (70) expr -> expr . > expr
    (71) expr -> expr . GE expr
    (72) expr -> expr . < expr
    (73) expr -> expr . LE expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    ]               reduce using rule 71 (expr -> expr GE expr .)
    >               reduce using rule 71 (expr -> expr GE expr .)
    GE              reduce using rule 71 (expr -> expr GE expr .)
    <               reduce using rule 71 (expr -> expr GE expr .)
    LE              reduce using rule 71 (expr -> expr GE expr .)
    NE              reduce using rule 71 (expr -> expr GE expr .)
    EQ              reduce using rule 71 (expr -> expr GE expr .)
    AND             reduce using rule 71 (expr -> expr GE expr .)
    OR              reduce using rule 71 (expr -> expr GE expr .)
    ;               reduce using rule 71 (expr -> expr GE expr .)
    )               reduce using rule 71 (expr -> expr GE expr .)
    ,               reduce using rule 71 (expr -> expr GE expr .)
    DEC             shift and go to state 53
    INC             shift and go to state 54
    MOD             shift and go to state 55
    DIVIDE          shift and go to state 56
    TIMES           shift and go to state 57
    MINUS           shift and go to state 58
    PLUS            shift and go to state 59


state 100

    (72) expr -> expr < expr .
    (58) expr -> expr . DEC
    (59) expr -> expr . INC
    (65) expr -> expr . MOD expr
    (66) expr -> expr . DIVIDE expr
    (67) expr -> expr . TIMES expr
    (68) expr -> expr . MINUS expr
    (69) expr -> expr . PLUS expr
    (70) expr -> expr . > expr
    (71) expr -> expr . GE expr
    (72) expr -> expr . < expr
    (73) expr -> expr . LE expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    ]               reduce using rule 72 (expr -> expr < expr .)
    >               reduce using rule 72 (expr -> expr < expr .)
    GE              reduce using rule 72 (expr -> expr < expr .)
    <               reduce using rule 72 (expr -> expr < expr .)
    LE              reduce using rule 72 (expr -> expr < expr .)
    NE              reduce using rule 72 (expr -> expr < expr .)
    EQ              reduce using rule 72 (expr -> expr < expr .)
    AND             reduce using rule 72 (expr -> expr < expr .)
    OR              reduce using rule 72 (expr -> expr < expr .)
    ;               reduce using rule 72 (expr -> expr < expr .)
    )               reduce using rule 72 (expr -> expr < expr .)
    ,               reduce using rule 72 (expr -> expr < expr .)
    DEC             shift and go to state 53
    INC             shift and go to state 54
    MOD             shift and go to state 55
    DIVIDE          shift and go to state 56
    TIMES           shift and go to state 57
    MINUS           shift and go to state 58
    PLUS            shift and go to state 59


state 101

    (73) expr -> expr LE expr .
    (58) expr -> expr . DEC
    (59) expr -> expr . INC
    (65) expr -> expr . MOD expr
    (66) expr -> expr . DIVIDE expr
    (67) expr -> expr . TIMES expr
    (68) expr -> expr . MINUS expr
    (69) expr -> expr . PLUS expr
    (70) expr -> expr . > expr
    (71) expr -> expr . GE expr
    (72) expr -> expr . < expr
    (73) expr -> expr . LE expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    ]               reduce using rule 73 (expr -> expr LE expr .)
    >               reduce using rule 73 (expr -> expr LE expr .)
    GE              reduce using rule 73 (expr -> expr LE expr .)
    <               reduce using rule 73 (expr -> expr LE expr .)
    LE              reduce using rule 73 (expr -> expr LE expr .)
    NE              reduce using rule 73 (expr -> expr LE expr .)
    EQ              reduce using rule 73 (expr -> expr LE expr .)
    AND             reduce using rule 73 (expr -> expr LE expr .)
    OR              reduce using rule 73 (expr -> expr LE expr .)
    ;               reduce using rule 73 (expr -> expr LE expr .)
    )               reduce using rule 73 (expr -> expr LE expr .)
    ,               reduce using rule 73 (expr -> expr LE expr .)
    DEC             shift and go to state 53
    INC             shift and go to state 54
    MOD             shift and go to state 55
    DIVIDE          shift and go to state 56
    TIMES           shift and go to state 57
    MINUS           shift and go to state 58
    PLUS            shift and go to state 59


state 102

    (74) expr -> expr NE expr .
    (58) expr -> expr . DEC
    (59) expr -> expr . INC
    (65) expr -> expr . MOD expr
    (66) expr -> expr . DIVIDE expr
    (67) expr -> expr . TIMES expr
    (68) expr -> expr . MINUS expr
    (69) expr -> expr . PLUS expr
    (70) expr -> expr . > expr
    (71) expr -> expr . GE expr
    (72) expr -> expr . < expr
    (73) expr -> expr . LE expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    ]               reduce using rule 74 (expr -> expr NE expr .)
    NE              reduce using rule 74 (expr -> expr NE expr .)
    EQ              reduce using rule 74 (expr -> expr NE expr .)
    AND             reduce using rule 74 (expr -> expr NE expr .)
    OR              reduce using rule 74 (expr -> expr NE expr .)
    ;               reduce using rule 74 (expr -> expr NE expr .)
    )               reduce using rule 74 (expr -> expr NE expr .)
    ,               reduce using rule 74 (expr -> expr NE expr .)
    DEC             shift and go to state 53
    INC             shift and go to state 54
    MOD             shift and go to state 55
    DIVIDE          shift and go to state 56
    TIMES           shift and go to state 57
    MINUS           shift and go to state 58
    PLUS            shift and go to state 59
    >               shift and go to state 60
    GE              shift and go to state 61
    <               shift and go to state 62
    LE              shift and go to state 63


state 103

    (75) expr -> expr EQ expr .
    (58) expr -> expr . DEC
    (59) expr -> expr . INC
    (65) expr -> expr . MOD expr
    (66) expr -> expr . DIVIDE expr
    (67) expr -> expr . TIMES expr
    (68) expr -> expr . MINUS expr
    (69) expr -> expr . PLUS expr
    (70) expr -> expr . > expr
    (71) expr -> expr . GE expr
    (72) expr -> expr . < expr
    (73) expr -> expr . LE expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    ]               reduce using rule 75 (expr -> expr EQ expr .)
    NE              reduce using rule 75 (expr -> expr EQ expr .)
    EQ              reduce using rule 75 (expr -> expr EQ expr .)
    AND             reduce using rule 75 (expr -> expr EQ expr .)
    OR              reduce using rule 75 (expr -> expr EQ expr .)
    ;               reduce using rule 75 (expr -> expr EQ expr .)
    )               reduce using rule 75 (expr -> expr EQ expr .)
    ,               reduce using rule 75 (expr -> expr EQ expr .)
    DEC             shift and go to state 53
    INC             shift and go to state 54
    MOD             shift and go to state 55
    DIVIDE          shift and go to state 56
    TIMES           shift and go to state 57
    MINUS           shift and go to state 58
    PLUS            shift and go to state 59
    >               shift and go to state 60
    GE              shift and go to state 61
    <               shift and go to state 62
    LE              shift and go to state 63


state 104

    (76) expr -> expr AND expr .
    (58) expr -> expr . DEC
    (59) expr -> expr . INC
    (65) expr -> expr . MOD expr
    (66) expr -> expr . DIVIDE expr
    (67) expr -> expr . TIMES expr
    (68) expr -> expr . MINUS expr
    (69) expr -> expr . PLUS expr
    (70) expr -> expr . > expr
    (71) expr -> expr . GE expr
    (72) expr -> expr . < expr
    (73) expr -> expr . LE expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    ]               reduce using rule 76 (expr -> expr AND expr .)
    AND             reduce using rule 76 (expr -> expr AND expr .)
    OR              reduce using rule 76 (expr -> expr AND expr .)
    ;               reduce using rule 76 (expr -> expr AND expr .)
    )               reduce using rule 76 (expr -> expr AND expr .)
    ,               reduce using rule 76 (expr -> expr AND expr .)
    DEC             shift and go to state 53
    INC             shift and go to state 54
    MOD             shift and go to state 55
    DIVIDE          shift and go to state 56
    TIMES           shift and go to state 57
    MINUS           shift and go to state 58
    PLUS            shift and go to state 59
    >               shift and go to state 60
    GE              shift and go to state 61
    <               shift and go to state 62
    LE              shift and go to state 63
    NE              shift and go to state 64
    EQ              shift and go to state 65


state 105

    (77) expr -> expr OR expr .
    (58) expr -> expr . DEC
    (59) expr -> expr . INC
    (65) expr -> expr . MOD expr
    (66) expr -> expr . DIVIDE expr
    (67) expr -> expr . TIMES expr
    (68) expr -> expr . MINUS expr
    (69) expr -> expr . PLUS expr
    (70) expr -> expr . > expr
    (71) expr -> expr . GE expr
    (72) expr -> expr . < expr
    (73) expr -> expr . LE expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    ]               reduce using rule 77 (expr -> expr OR expr .)
    OR              reduce using rule 77 (expr -> expr OR expr .)
    ;               reduce using rule 77 (expr -> expr OR expr .)
    )               reduce using rule 77 (expr -> expr OR expr .)
    ,               reduce using rule 77 (expr -> expr OR expr .)
    DEC             shift and go to state 53
    INC             shift and go to state 54
    MOD             shift and go to state 55
    DIVIDE          shift and go to state 56
    TIMES           shift and go to state 57
    MINUS           shift and go to state 58
    PLUS            shift and go to state 59
    >               shift and go to state 60
    GE              shift and go to state 61
    <               shift and go to state 62
    LE              shift and go to state 63
    NE              shift and go to state 64
    EQ              shift and go to state 65
    AND             shift and go to state 66


state 106

    (45) expr -> NEW type_spec [ . expr ]
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING_LIT
    (47) expr -> . CHAR_LIT
    (48) expr -> . FLOAT_LIT
    (49) expr -> . INT_LIT
    (50) expr -> . FALSE
    (51) expr -> . TRUE
    (52) expr -> . BOOL_LIT
    (53) expr -> . IDENT . SIZE
    (54) expr -> . IDENT ( args )
    (55) expr -> . IDENT [ expr ]
    (56) expr -> . IDENT
    (57) expr -> . ( expr )
    (58) expr -> . expr DEC
    (59) expr -> . expr INC
    (60) expr -> . DEC expr
    (61) expr -> . INC expr
    (62) expr -> . PLUS expr
    (63) expr -> . MINUS expr
    (64) expr -> . ! expr
    (65) expr -> . expr MOD expr
    (66) expr -> . expr DIVIDE expr
    (67) expr -> . expr TIMES expr
    (68) expr -> . expr MINUS expr
    (69) expr -> . expr PLUS expr
    (70) expr -> . expr > expr
    (71) expr -> . expr GE expr
    (72) expr -> . expr < expr
    (73) expr -> . expr LE expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT [ expr ] = expr
    (79) expr -> . IDENT MODASSIGN expr
    (80) expr -> . IDENT DIVASSIGN expr
    (81) expr -> . IDENT MULASSIGN expr
    (82) expr -> . IDENT SUBASSIGN expr
    (83) expr -> . IDENT ADDASSIGN expr
    (84) expr -> . IDENT = expr
    NEW             shift and go to state 25
    STRING_LIT      shift and go to state 26
    CHAR_LIT        shift and go to state 27
    FLOAT_LIT       shift and go to state 28
    INT_LIT         shift and go to state 29
    FALSE           shift and go to state 30
    TRUE            shift and go to state 31
    BOOL_LIT        shift and go to state 32
    IDENT           shift and go to state 23
    (               shift and go to state 33
    DEC             shift and go to state 34
    INC             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    !               shift and go to state 38

    expr                           shift and go to state 114

state 107

    (57) expr -> ( expr ) .
    ]               reduce using rule 57 (expr -> ( expr ) .)
    DEC             reduce using rule 57 (expr -> ( expr ) .)
    INC             reduce using rule 57 (expr -> ( expr ) .)
    MOD             reduce using rule 57 (expr -> ( expr ) .)
    DIVIDE          reduce using rule 57 (expr -> ( expr ) .)
    TIMES           reduce using rule 57 (expr -> ( expr ) .)
    MINUS           reduce using rule 57 (expr -> ( expr ) .)
    PLUS            reduce using rule 57 (expr -> ( expr ) .)
    >               reduce using rule 57 (expr -> ( expr ) .)
    GE              reduce using rule 57 (expr -> ( expr ) .)
    <               reduce using rule 57 (expr -> ( expr ) .)
    LE              reduce using rule 57 (expr -> ( expr ) .)
    NE              reduce using rule 57 (expr -> ( expr ) .)
    EQ              reduce using rule 57 (expr -> ( expr ) .)
    AND             reduce using rule 57 (expr -> ( expr ) .)
    OR              reduce using rule 57 (expr -> ( expr ) .)
    ;               reduce using rule 57 (expr -> ( expr ) .)
    )               reduce using rule 57 (expr -> ( expr ) .)
    ,               reduce using rule 57 (expr -> ( expr ) .)


state 108

    (19) param -> type_spec IDENT [ ] .
    ,               reduce using rule 19 (param -> type_spec IDENT [ ] .)
    )               reduce using rule 19 (param -> type_spec IDENT [ ] .)


state 109

    (21) compound_stmt -> { local_decls . stmt_list }
    (23) local_decls -> local_decls . local_decl
    (27) stmt_list -> . empty
    (28) stmt_list -> . stmt_list stmt
    (24) local_decl -> . type_spec IDENT [ expr ] ;
    (25) local_decl -> . type_spec IDENT = expr ;
    (26) local_decl -> . type_spec IDENT ;
    (89) empty -> .
    (9) type_spec -> . CHAR
    (10) type_spec -> . FLOAT
    (11) type_spec -> . INT
    (12) type_spec -> . BOOL
    (13) type_spec -> . VOID
    }               reduce using rule 89 (empty -> .)
    BREAK           reduce using rule 89 (empty -> .)
    RETURN          reduce using rule 89 (empty -> .)
    FOR             reduce using rule 89 (empty -> .)
    WHILE           reduce using rule 89 (empty -> .)
    IF              reduce using rule 89 (empty -> .)
    {               reduce using rule 89 (empty -> .)
    ;               reduce using rule 89 (empty -> .)
    NEW             reduce using rule 89 (empty -> .)
    STRING_LIT      reduce using rule 89 (empty -> .)
    CHAR_LIT        reduce using rule 89 (empty -> .)
    FLOAT_LIT       reduce using rule 89 (empty -> .)
    INT_LIT         reduce using rule 89 (empty -> .)
    FALSE           reduce using rule 89 (empty -> .)
    TRUE            reduce using rule 89 (empty -> .)
    BOOL_LIT        reduce using rule 89 (empty -> .)
    IDENT           reduce using rule 89 (empty -> .)
    (               reduce using rule 89 (empty -> .)
    DEC             reduce using rule 89 (empty -> .)
    INC             reduce using rule 89 (empty -> .)
    PLUS            reduce using rule 89 (empty -> .)
    MINUS           reduce using rule 89 (empty -> .)
    !               reduce using rule 89 (empty -> .)
    CHAR            shift and go to state 7
    FLOAT           shift and go to state 8
    INT             shift and go to state 9
    BOOL            shift and go to state 10
    VOID            shift and go to state 11

    stmt_list                      shift and go to state 115
    local_decl                     shift and go to state 116
    empty                          shift and go to state 117
    type_spec                      shift and go to state 118

state 110

    (22) local_decls -> empty .
    CHAR            reduce using rule 22 (local_decls -> empty .)
    FLOAT           reduce using rule 22 (local_decls -> empty .)
    INT             reduce using rule 22 (local_decls -> empty .)
    BOOL            reduce using rule 22 (local_decls -> empty .)
    VOID            reduce using rule 22 (local_decls -> empty .)
    }               reduce using rule 22 (local_decls -> empty .)
    BREAK           reduce using rule 22 (local_decls -> empty .)
    RETURN          reduce using rule 22 (local_decls -> empty .)
    FOR             reduce using rule 22 (local_decls -> empty .)
    WHILE           reduce using rule 22 (local_decls -> empty .)
    IF              reduce using rule 22 (local_decls -> empty .)
    {               reduce using rule 22 (local_decls -> empty .)
    ;               reduce using rule 22 (local_decls -> empty .)
    NEW             reduce using rule 22 (local_decls -> empty .)
    STRING_LIT      reduce using rule 22 (local_decls -> empty .)
    CHAR_LIT        reduce using rule 22 (local_decls -> empty .)
    FLOAT_LIT       reduce using rule 22 (local_decls -> empty .)
    INT_LIT         reduce using rule 22 (local_decls -> empty .)
    FALSE           reduce using rule 22 (local_decls -> empty .)
    TRUE            reduce using rule 22 (local_decls -> empty .)
    BOOL_LIT        reduce using rule 22 (local_decls -> empty .)
    IDENT           reduce using rule 22 (local_decls -> empty .)
    (               reduce using rule 22 (local_decls -> empty .)
    DEC             reduce using rule 22 (local_decls -> empty .)
    INC             reduce using rule 22 (local_decls -> empty .)
    PLUS            reduce using rule 22 (local_decls -> empty .)
    MINUS           reduce using rule 22 (local_decls -> empty .)
    !               reduce using rule 22 (local_decls -> empty .)


state 111

    (54) expr -> IDENT ( args ) .
    ]               reduce using rule 54 (expr -> IDENT ( args ) .)
    DEC             reduce using rule 54 (expr -> IDENT ( args ) .)
    INC             reduce using rule 54 (expr -> IDENT ( args ) .)
    MOD             reduce using rule 54 (expr -> IDENT ( args ) .)
    DIVIDE          reduce using rule 54 (expr -> IDENT ( args ) .)
    TIMES           reduce using rule 54 (expr -> IDENT ( args ) .)
    MINUS           reduce using rule 54 (expr -> IDENT ( args ) .)
    PLUS            reduce using rule 54 (expr -> IDENT ( args ) .)
    >               reduce using rule 54 (expr -> IDENT ( args ) .)
    GE              reduce using rule 54 (expr -> IDENT ( args ) .)
    <               reduce using rule 54 (expr -> IDENT ( args ) .)
    LE              reduce using rule 54 (expr -> IDENT ( args ) .)
    NE              reduce using rule 54 (expr -> IDENT ( args ) .)
    EQ              reduce using rule 54 (expr -> IDENT ( args ) .)
    AND             reduce using rule 54 (expr -> IDENT ( args ) .)
    OR              reduce using rule 54 (expr -> IDENT ( args ) .)
    ;               reduce using rule 54 (expr -> IDENT ( args ) .)
    )               reduce using rule 54 (expr -> IDENT ( args ) .)
    ,               reduce using rule 54 (expr -> IDENT ( args ) .)


state 112

    (86) arg_list -> arg_list , . expr
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING_LIT
    (47) expr -> . CHAR_LIT
    (48) expr -> . FLOAT_LIT
    (49) expr -> . INT_LIT
    (50) expr -> . FALSE
    (51) expr -> . TRUE
    (52) expr -> . BOOL_LIT
    (53) expr -> . IDENT . SIZE
    (54) expr -> . IDENT ( args )
    (55) expr -> . IDENT [ expr ]
    (56) expr -> . IDENT
    (57) expr -> . ( expr )
    (58) expr -> . expr DEC
    (59) expr -> . expr INC
    (60) expr -> . DEC expr
    (61) expr -> . INC expr
    (62) expr -> . PLUS expr
    (63) expr -> . MINUS expr
    (64) expr -> . ! expr
    (65) expr -> . expr MOD expr
    (66) expr -> . expr DIVIDE expr
    (67) expr -> . expr TIMES expr
    (68) expr -> . expr MINUS expr
    (69) expr -> . expr PLUS expr
    (70) expr -> . expr > expr
    (71) expr -> . expr GE expr
    (72) expr -> . expr < expr
    (73) expr -> . expr LE expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT [ expr ] = expr
    (79) expr -> . IDENT MODASSIGN expr
    (80) expr -> . IDENT DIVASSIGN expr
    (81) expr -> . IDENT MULASSIGN expr
    (82) expr -> . IDENT SUBASSIGN expr
    (83) expr -> . IDENT ADDASSIGN expr
    (84) expr -> . IDENT = expr
    NEW             shift and go to state 25
    STRING_LIT      shift and go to state 26
    CHAR_LIT        shift and go to state 27
    FLOAT_LIT       shift and go to state 28
    INT_LIT         shift and go to state 29
    FALSE           shift and go to state 30
    TRUE            shift and go to state 31
    BOOL_LIT        shift and go to state 32
    IDENT           shift and go to state 23
    (               shift and go to state 33
    DEC             shift and go to state 34
    INC             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    !               shift and go to state 38

    expr                           shift and go to state 119

state 113

    (55) expr -> IDENT [ expr ] .
    (78) expr -> IDENT [ expr ] . = expr
    ]               reduce using rule 55 (expr -> IDENT [ expr ] .)
    DEC             reduce using rule 55 (expr -> IDENT [ expr ] .)
    INC             reduce using rule 55 (expr -> IDENT [ expr ] .)
    MOD             reduce using rule 55 (expr -> IDENT [ expr ] .)
    DIVIDE          reduce using rule 55 (expr -> IDENT [ expr ] .)
    TIMES           reduce using rule 55 (expr -> IDENT [ expr ] .)
    MINUS           reduce using rule 55 (expr -> IDENT [ expr ] .)
    PLUS            reduce using rule 55 (expr -> IDENT [ expr ] .)
    >               reduce using rule 55 (expr -> IDENT [ expr ] .)
    GE              reduce using rule 55 (expr -> IDENT [ expr ] .)
    <               reduce using rule 55 (expr -> IDENT [ expr ] .)
    LE              reduce using rule 55 (expr -> IDENT [ expr ] .)
    NE              reduce using rule 55 (expr -> IDENT [ expr ] .)
    EQ              reduce using rule 55 (expr -> IDENT [ expr ] .)
    AND             reduce using rule 55 (expr -> IDENT [ expr ] .)
    OR              reduce using rule 55 (expr -> IDENT [ expr ] .)
    ;               reduce using rule 55 (expr -> IDENT [ expr ] .)
    )               reduce using rule 55 (expr -> IDENT [ expr ] .)
    ,               reduce using rule 55 (expr -> IDENT [ expr ] .)
    =               shift and go to state 120


state 114

    (45) expr -> NEW type_spec [ expr . ]
    (58) expr -> expr . DEC
    (59) expr -> expr . INC
    (65) expr -> expr . MOD expr
    (66) expr -> expr . DIVIDE expr
    (67) expr -> expr . TIMES expr
    (68) expr -> expr . MINUS expr
    (69) expr -> expr . PLUS expr
    (70) expr -> expr . > expr
    (71) expr -> expr . GE expr
    (72) expr -> expr . < expr
    (73) expr -> expr . LE expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    ]               shift and go to state 121
    DEC             shift and go to state 53
    INC             shift and go to state 54
    MOD             shift and go to state 55
    DIVIDE          shift and go to state 56
    TIMES           shift and go to state 57
    MINUS           shift and go to state 58
    PLUS            shift and go to state 59
    >               shift and go to state 60
    GE              shift and go to state 61
    <               shift and go to state 62
    LE              shift and go to state 63
    NE              shift and go to state 64
    EQ              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 115

    (21) compound_stmt -> { local_decls stmt_list . }
    (28) stmt_list -> stmt_list . stmt
    (29) stmt -> . break_stmt
    (30) stmt -> . return_stmt
    (31) stmt -> . for_stmt
    (32) stmt -> . while_stmt
    (33) stmt -> . if_stmt
    (34) stmt -> . compound_stmt
    (35) stmt -> . expr_stmt
    (44) break_stmt -> . BREAK ;
    (42) return_stmt -> . RETURN expr ;
    (43) return_stmt -> . RETURN ;
    (39) for_stmt -> . FOR ( args ; args ; args ) stmt
    (38) while_stmt -> . WHILE ( expr ) stmt
    (40) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (41) if_stmt -> . IF ( expr ) stmt
    (21) compound_stmt -> . { local_decls stmt_list }
    (36) expr_stmt -> . ;
    (37) expr_stmt -> . expr ;
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING_LIT
    (47) expr -> . CHAR_LIT
    (48) expr -> . FLOAT_LIT
    (49) expr -> . INT_LIT
    (50) expr -> . FALSE
    (51) expr -> . TRUE
    (52) expr -> . BOOL_LIT
    (53) expr -> . IDENT . SIZE
    (54) expr -> . IDENT ( args )
    (55) expr -> . IDENT [ expr ]
    (56) expr -> . IDENT
    (57) expr -> . ( expr )
    (58) expr -> . expr DEC
    (59) expr -> . expr INC
    (60) expr -> . DEC expr
    (61) expr -> . INC expr
    (62) expr -> . PLUS expr
    (63) expr -> . MINUS expr
    (64) expr -> . ! expr
    (65) expr -> . expr MOD expr
    (66) expr -> . expr DIVIDE expr
    (67) expr -> . expr TIMES expr
    (68) expr -> . expr MINUS expr
    (69) expr -> . expr PLUS expr
    (70) expr -> . expr > expr
    (71) expr -> . expr GE expr
    (72) expr -> . expr < expr
    (73) expr -> . expr LE expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT [ expr ] = expr
    (79) expr -> . IDENT MODASSIGN expr
    (80) expr -> . IDENT DIVASSIGN expr
    (81) expr -> . IDENT MULASSIGN expr
    (82) expr -> . IDENT SUBASSIGN expr
    (83) expr -> . IDENT ADDASSIGN expr
    (84) expr -> . IDENT = expr
    }               shift and go to state 122
    BREAK           shift and go to state 131
    RETURN          shift and go to state 133
    FOR             shift and go to state 135
    WHILE           shift and go to state 136
    IF              shift and go to state 137
    {               shift and go to state 78
    ;               shift and go to state 132
    NEW             shift and go to state 25
    STRING_LIT      shift and go to state 26
    CHAR_LIT        shift and go to state 27
    FLOAT_LIT       shift and go to state 28
    INT_LIT         shift and go to state 29
    FALSE           shift and go to state 30
    TRUE            shift and go to state 31
    BOOL_LIT        shift and go to state 32
    IDENT           shift and go to state 23
    (               shift and go to state 33
    DEC             shift and go to state 34
    INC             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    !               shift and go to state 38

    stmt                           shift and go to state 123
    break_stmt                     shift and go to state 124
    return_stmt                    shift and go to state 125
    for_stmt                       shift and go to state 126
    while_stmt                     shift and go to state 127
    if_stmt                        shift and go to state 128
    compound_stmt                  shift and go to state 129
    expr_stmt                      shift and go to state 130
    expr                           shift and go to state 134

state 116

    (23) local_decls -> local_decls local_decl .
    CHAR            reduce using rule 23 (local_decls -> local_decls local_decl .)
    FLOAT           reduce using rule 23 (local_decls -> local_decls local_decl .)
    INT             reduce using rule 23 (local_decls -> local_decls local_decl .)
    BOOL            reduce using rule 23 (local_decls -> local_decls local_decl .)
    VOID            reduce using rule 23 (local_decls -> local_decls local_decl .)
    }               reduce using rule 23 (local_decls -> local_decls local_decl .)
    BREAK           reduce using rule 23 (local_decls -> local_decls local_decl .)
    RETURN          reduce using rule 23 (local_decls -> local_decls local_decl .)
    FOR             reduce using rule 23 (local_decls -> local_decls local_decl .)
    WHILE           reduce using rule 23 (local_decls -> local_decls local_decl .)
    IF              reduce using rule 23 (local_decls -> local_decls local_decl .)
    {               reduce using rule 23 (local_decls -> local_decls local_decl .)
    ;               reduce using rule 23 (local_decls -> local_decls local_decl .)
    NEW             reduce using rule 23 (local_decls -> local_decls local_decl .)
    STRING_LIT      reduce using rule 23 (local_decls -> local_decls local_decl .)
    CHAR_LIT        reduce using rule 23 (local_decls -> local_decls local_decl .)
    FLOAT_LIT       reduce using rule 23 (local_decls -> local_decls local_decl .)
    INT_LIT         reduce using rule 23 (local_decls -> local_decls local_decl .)
    FALSE           reduce using rule 23 (local_decls -> local_decls local_decl .)
    TRUE            reduce using rule 23 (local_decls -> local_decls local_decl .)
    BOOL_LIT        reduce using rule 23 (local_decls -> local_decls local_decl .)
    IDENT           reduce using rule 23 (local_decls -> local_decls local_decl .)
    (               reduce using rule 23 (local_decls -> local_decls local_decl .)
    DEC             reduce using rule 23 (local_decls -> local_decls local_decl .)
    INC             reduce using rule 23 (local_decls -> local_decls local_decl .)
    PLUS            reduce using rule 23 (local_decls -> local_decls local_decl .)
    MINUS           reduce using rule 23 (local_decls -> local_decls local_decl .)
    !               reduce using rule 23 (local_decls -> local_decls local_decl .)


state 117

    (27) stmt_list -> empty .
    }               reduce using rule 27 (stmt_list -> empty .)
    BREAK           reduce using rule 27 (stmt_list -> empty .)
    RETURN          reduce using rule 27 (stmt_list -> empty .)
    FOR             reduce using rule 27 (stmt_list -> empty .)
    WHILE           reduce using rule 27 (stmt_list -> empty .)
    IF              reduce using rule 27 (stmt_list -> empty .)
    {               reduce using rule 27 (stmt_list -> empty .)
    ;               reduce using rule 27 (stmt_list -> empty .)
    NEW             reduce using rule 27 (stmt_list -> empty .)
    STRING_LIT      reduce using rule 27 (stmt_list -> empty .)
    CHAR_LIT        reduce using rule 27 (stmt_list -> empty .)
    FLOAT_LIT       reduce using rule 27 (stmt_list -> empty .)
    INT_LIT         reduce using rule 27 (stmt_list -> empty .)
    FALSE           reduce using rule 27 (stmt_list -> empty .)
    TRUE            reduce using rule 27 (stmt_list -> empty .)
    BOOL_LIT        reduce using rule 27 (stmt_list -> empty .)
    IDENT           reduce using rule 27 (stmt_list -> empty .)
    (               reduce using rule 27 (stmt_list -> empty .)
    DEC             reduce using rule 27 (stmt_list -> empty .)
    INC             reduce using rule 27 (stmt_list -> empty .)
    PLUS            reduce using rule 27 (stmt_list -> empty .)
    MINUS           reduce using rule 27 (stmt_list -> empty .)
    !               reduce using rule 27 (stmt_list -> empty .)


state 118

    (24) local_decl -> type_spec . IDENT [ expr ] ;
    (25) local_decl -> type_spec . IDENT = expr ;
    (26) local_decl -> type_spec . IDENT ;
    IDENT           shift and go to state 138


state 119

    (86) arg_list -> arg_list , expr .
    (58) expr -> expr . DEC
    (59) expr -> expr . INC
    (65) expr -> expr . MOD expr
    (66) expr -> expr . DIVIDE expr
    (67) expr -> expr . TIMES expr
    (68) expr -> expr . MINUS expr
    (69) expr -> expr . PLUS expr
    (70) expr -> expr . > expr
    (71) expr -> expr . GE expr
    (72) expr -> expr . < expr
    (73) expr -> expr . LE expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    ,               reduce using rule 86 (arg_list -> arg_list , expr .)
    )               reduce using rule 86 (arg_list -> arg_list , expr .)
    ;               reduce using rule 86 (arg_list -> arg_list , expr .)
    DEC             shift and go to state 53
    INC             shift and go to state 54
    MOD             shift and go to state 55
    DIVIDE          shift and go to state 56
    TIMES           shift and go to state 57
    MINUS           shift and go to state 58
    PLUS            shift and go to state 59
    >               shift and go to state 60
    GE              shift and go to state 61
    <               shift and go to state 62
    LE              shift and go to state 63
    NE              shift and go to state 64
    EQ              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 120

    (78) expr -> IDENT [ expr ] = . expr
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING_LIT
    (47) expr -> . CHAR_LIT
    (48) expr -> . FLOAT_LIT
    (49) expr -> . INT_LIT
    (50) expr -> . FALSE
    (51) expr -> . TRUE
    (52) expr -> . BOOL_LIT
    (53) expr -> . IDENT . SIZE
    (54) expr -> . IDENT ( args )
    (55) expr -> . IDENT [ expr ]
    (56) expr -> . IDENT
    (57) expr -> . ( expr )
    (58) expr -> . expr DEC
    (59) expr -> . expr INC
    (60) expr -> . DEC expr
    (61) expr -> . INC expr
    (62) expr -> . PLUS expr
    (63) expr -> . MINUS expr
    (64) expr -> . ! expr
    (65) expr -> . expr MOD expr
    (66) expr -> . expr DIVIDE expr
    (67) expr -> . expr TIMES expr
    (68) expr -> . expr MINUS expr
    (69) expr -> . expr PLUS expr
    (70) expr -> . expr > expr
    (71) expr -> . expr GE expr
    (72) expr -> . expr < expr
    (73) expr -> . expr LE expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT [ expr ] = expr
    (79) expr -> . IDENT MODASSIGN expr
    (80) expr -> . IDENT DIVASSIGN expr
    (81) expr -> . IDENT MULASSIGN expr
    (82) expr -> . IDENT SUBASSIGN expr
    (83) expr -> . IDENT ADDASSIGN expr
    (84) expr -> . IDENT = expr
    NEW             shift and go to state 25
    STRING_LIT      shift and go to state 26
    CHAR_LIT        shift and go to state 27
    FLOAT_LIT       shift and go to state 28
    INT_LIT         shift and go to state 29
    FALSE           shift and go to state 30
    TRUE            shift and go to state 31
    BOOL_LIT        shift and go to state 32
    IDENT           shift and go to state 23
    (               shift and go to state 33
    DEC             shift and go to state 34
    INC             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    !               shift and go to state 38

    expr                           shift and go to state 139

state 121

    (45) expr -> NEW type_spec [ expr ] .
    ]               reduce using rule 45 (expr -> NEW type_spec [ expr ] .)
    DEC             reduce using rule 45 (expr -> NEW type_spec [ expr ] .)
    INC             reduce using rule 45 (expr -> NEW type_spec [ expr ] .)
    MOD             reduce using rule 45 (expr -> NEW type_spec [ expr ] .)
    DIVIDE          reduce using rule 45 (expr -> NEW type_spec [ expr ] .)
    TIMES           reduce using rule 45 (expr -> NEW type_spec [ expr ] .)
    MINUS           reduce using rule 45 (expr -> NEW type_spec [ expr ] .)
    PLUS            reduce using rule 45 (expr -> NEW type_spec [ expr ] .)
    >               reduce using rule 45 (expr -> NEW type_spec [ expr ] .)
    GE              reduce using rule 45 (expr -> NEW type_spec [ expr ] .)
    <               reduce using rule 45 (expr -> NEW type_spec [ expr ] .)
    LE              reduce using rule 45 (expr -> NEW type_spec [ expr ] .)
    NE              reduce using rule 45 (expr -> NEW type_spec [ expr ] .)
    EQ              reduce using rule 45 (expr -> NEW type_spec [ expr ] .)
    AND             reduce using rule 45 (expr -> NEW type_spec [ expr ] .)
    OR              reduce using rule 45 (expr -> NEW type_spec [ expr ] .)
    ;               reduce using rule 45 (expr -> NEW type_spec [ expr ] .)
    )               reduce using rule 45 (expr -> NEW type_spec [ expr ] .)
    ,               reduce using rule 45 (expr -> NEW type_spec [ expr ] .)


state 122

    (21) compound_stmt -> { local_decls stmt_list } .
    CHAR            reduce using rule 21 (compound_stmt -> { local_decls stmt_list } .)
    FLOAT           reduce using rule 21 (compound_stmt -> { local_decls stmt_list } .)
    INT             reduce using rule 21 (compound_stmt -> { local_decls stmt_list } .)
    BOOL            reduce using rule 21 (compound_stmt -> { local_decls stmt_list } .)
    VOID            reduce using rule 21 (compound_stmt -> { local_decls stmt_list } .)
    $end            reduce using rule 21 (compound_stmt -> { local_decls stmt_list } .)
    }               reduce using rule 21 (compound_stmt -> { local_decls stmt_list } .)
    BREAK           reduce using rule 21 (compound_stmt -> { local_decls stmt_list } .)
    RETURN          reduce using rule 21 (compound_stmt -> { local_decls stmt_list } .)
    FOR             reduce using rule 21 (compound_stmt -> { local_decls stmt_list } .)
    WHILE           reduce using rule 21 (compound_stmt -> { local_decls stmt_list } .)
    IF              reduce using rule 21 (compound_stmt -> { local_decls stmt_list } .)
    {               reduce using rule 21 (compound_stmt -> { local_decls stmt_list } .)
    ;               reduce using rule 21 (compound_stmt -> { local_decls stmt_list } .)
    NEW             reduce using rule 21 (compound_stmt -> { local_decls stmt_list } .)
    STRING_LIT      reduce using rule 21 (compound_stmt -> { local_decls stmt_list } .)
    CHAR_LIT        reduce using rule 21 (compound_stmt -> { local_decls stmt_list } .)
    FLOAT_LIT       reduce using rule 21 (compound_stmt -> { local_decls stmt_list } .)
    INT_LIT         reduce using rule 21 (compound_stmt -> { local_decls stmt_list } .)
    FALSE           reduce using rule 21 (compound_stmt -> { local_decls stmt_list } .)
    TRUE            reduce using rule 21 (compound_stmt -> { local_decls stmt_list } .)
    BOOL_LIT        reduce using rule 21 (compound_stmt -> { local_decls stmt_list } .)
    IDENT           reduce using rule 21 (compound_stmt -> { local_decls stmt_list } .)
    (               reduce using rule 21 (compound_stmt -> { local_decls stmt_list } .)
    DEC             reduce using rule 21 (compound_stmt -> { local_decls stmt_list } .)
    INC             reduce using rule 21 (compound_stmt -> { local_decls stmt_list } .)
    PLUS            reduce using rule 21 (compound_stmt -> { local_decls stmt_list } .)
    MINUS           reduce using rule 21 (compound_stmt -> { local_decls stmt_list } .)
    !               reduce using rule 21 (compound_stmt -> { local_decls stmt_list } .)
    ELSE            reduce using rule 21 (compound_stmt -> { local_decls stmt_list } .)


state 123

    (28) stmt_list -> stmt_list stmt .
    }               reduce using rule 28 (stmt_list -> stmt_list stmt .)
    BREAK           reduce using rule 28 (stmt_list -> stmt_list stmt .)
    RETURN          reduce using rule 28 (stmt_list -> stmt_list stmt .)
    FOR             reduce using rule 28 (stmt_list -> stmt_list stmt .)
    WHILE           reduce using rule 28 (stmt_list -> stmt_list stmt .)
    IF              reduce using rule 28 (stmt_list -> stmt_list stmt .)
    {               reduce using rule 28 (stmt_list -> stmt_list stmt .)
    ;               reduce using rule 28 (stmt_list -> stmt_list stmt .)
    NEW             reduce using rule 28 (stmt_list -> stmt_list stmt .)
    STRING_LIT      reduce using rule 28 (stmt_list -> stmt_list stmt .)
    CHAR_LIT        reduce using rule 28 (stmt_list -> stmt_list stmt .)
    FLOAT_LIT       reduce using rule 28 (stmt_list -> stmt_list stmt .)
    INT_LIT         reduce using rule 28 (stmt_list -> stmt_list stmt .)
    FALSE           reduce using rule 28 (stmt_list -> stmt_list stmt .)
    TRUE            reduce using rule 28 (stmt_list -> stmt_list stmt .)
    BOOL_LIT        reduce using rule 28 (stmt_list -> stmt_list stmt .)
    IDENT           reduce using rule 28 (stmt_list -> stmt_list stmt .)
    (               reduce using rule 28 (stmt_list -> stmt_list stmt .)
    DEC             reduce using rule 28 (stmt_list -> stmt_list stmt .)
    INC             reduce using rule 28 (stmt_list -> stmt_list stmt .)
    PLUS            reduce using rule 28 (stmt_list -> stmt_list stmt .)
    MINUS           reduce using rule 28 (stmt_list -> stmt_list stmt .)
    !               reduce using rule 28 (stmt_list -> stmt_list stmt .)


state 124

    (29) stmt -> break_stmt .
    }               reduce using rule 29 (stmt -> break_stmt .)
    BREAK           reduce using rule 29 (stmt -> break_stmt .)
    RETURN          reduce using rule 29 (stmt -> break_stmt .)
    FOR             reduce using rule 29 (stmt -> break_stmt .)
    WHILE           reduce using rule 29 (stmt -> break_stmt .)
    IF              reduce using rule 29 (stmt -> break_stmt .)
    {               reduce using rule 29 (stmt -> break_stmt .)
    ;               reduce using rule 29 (stmt -> break_stmt .)
    NEW             reduce using rule 29 (stmt -> break_stmt .)
    STRING_LIT      reduce using rule 29 (stmt -> break_stmt .)
    CHAR_LIT        reduce using rule 29 (stmt -> break_stmt .)
    FLOAT_LIT       reduce using rule 29 (stmt -> break_stmt .)
    INT_LIT         reduce using rule 29 (stmt -> break_stmt .)
    FALSE           reduce using rule 29 (stmt -> break_stmt .)
    TRUE            reduce using rule 29 (stmt -> break_stmt .)
    BOOL_LIT        reduce using rule 29 (stmt -> break_stmt .)
    IDENT           reduce using rule 29 (stmt -> break_stmt .)
    (               reduce using rule 29 (stmt -> break_stmt .)
    DEC             reduce using rule 29 (stmt -> break_stmt .)
    INC             reduce using rule 29 (stmt -> break_stmt .)
    PLUS            reduce using rule 29 (stmt -> break_stmt .)
    MINUS           reduce using rule 29 (stmt -> break_stmt .)
    !               reduce using rule 29 (stmt -> break_stmt .)
    ELSE            reduce using rule 29 (stmt -> break_stmt .)


state 125

    (30) stmt -> return_stmt .
    }               reduce using rule 30 (stmt -> return_stmt .)
    BREAK           reduce using rule 30 (stmt -> return_stmt .)
    RETURN          reduce using rule 30 (stmt -> return_stmt .)
    FOR             reduce using rule 30 (stmt -> return_stmt .)
    WHILE           reduce using rule 30 (stmt -> return_stmt .)
    IF              reduce using rule 30 (stmt -> return_stmt .)
    {               reduce using rule 30 (stmt -> return_stmt .)
    ;               reduce using rule 30 (stmt -> return_stmt .)
    NEW             reduce using rule 30 (stmt -> return_stmt .)
    STRING_LIT      reduce using rule 30 (stmt -> return_stmt .)
    CHAR_LIT        reduce using rule 30 (stmt -> return_stmt .)
    FLOAT_LIT       reduce using rule 30 (stmt -> return_stmt .)
    INT_LIT         reduce using rule 30 (stmt -> return_stmt .)
    FALSE           reduce using rule 30 (stmt -> return_stmt .)
    TRUE            reduce using rule 30 (stmt -> return_stmt .)
    BOOL_LIT        reduce using rule 30 (stmt -> return_stmt .)
    IDENT           reduce using rule 30 (stmt -> return_stmt .)
    (               reduce using rule 30 (stmt -> return_stmt .)
    DEC             reduce using rule 30 (stmt -> return_stmt .)
    INC             reduce using rule 30 (stmt -> return_stmt .)
    PLUS            reduce using rule 30 (stmt -> return_stmt .)
    MINUS           reduce using rule 30 (stmt -> return_stmt .)
    !               reduce using rule 30 (stmt -> return_stmt .)
    ELSE            reduce using rule 30 (stmt -> return_stmt .)


state 126

    (31) stmt -> for_stmt .
    }               reduce using rule 31 (stmt -> for_stmt .)
    BREAK           reduce using rule 31 (stmt -> for_stmt .)
    RETURN          reduce using rule 31 (stmt -> for_stmt .)
    FOR             reduce using rule 31 (stmt -> for_stmt .)
    WHILE           reduce using rule 31 (stmt -> for_stmt .)
    IF              reduce using rule 31 (stmt -> for_stmt .)
    {               reduce using rule 31 (stmt -> for_stmt .)
    ;               reduce using rule 31 (stmt -> for_stmt .)
    NEW             reduce using rule 31 (stmt -> for_stmt .)
    STRING_LIT      reduce using rule 31 (stmt -> for_stmt .)
    CHAR_LIT        reduce using rule 31 (stmt -> for_stmt .)
    FLOAT_LIT       reduce using rule 31 (stmt -> for_stmt .)
    INT_LIT         reduce using rule 31 (stmt -> for_stmt .)
    FALSE           reduce using rule 31 (stmt -> for_stmt .)
    TRUE            reduce using rule 31 (stmt -> for_stmt .)
    BOOL_LIT        reduce using rule 31 (stmt -> for_stmt .)
    IDENT           reduce using rule 31 (stmt -> for_stmt .)
    (               reduce using rule 31 (stmt -> for_stmt .)
    DEC             reduce using rule 31 (stmt -> for_stmt .)
    INC             reduce using rule 31 (stmt -> for_stmt .)
    PLUS            reduce using rule 31 (stmt -> for_stmt .)
    MINUS           reduce using rule 31 (stmt -> for_stmt .)
    !               reduce using rule 31 (stmt -> for_stmt .)
    ELSE            reduce using rule 31 (stmt -> for_stmt .)


state 127

    (32) stmt -> while_stmt .
    }               reduce using rule 32 (stmt -> while_stmt .)
    BREAK           reduce using rule 32 (stmt -> while_stmt .)
    RETURN          reduce using rule 32 (stmt -> while_stmt .)
    FOR             reduce using rule 32 (stmt -> while_stmt .)
    WHILE           reduce using rule 32 (stmt -> while_stmt .)
    IF              reduce using rule 32 (stmt -> while_stmt .)
    {               reduce using rule 32 (stmt -> while_stmt .)
    ;               reduce using rule 32 (stmt -> while_stmt .)
    NEW             reduce using rule 32 (stmt -> while_stmt .)
    STRING_LIT      reduce using rule 32 (stmt -> while_stmt .)
    CHAR_LIT        reduce using rule 32 (stmt -> while_stmt .)
    FLOAT_LIT       reduce using rule 32 (stmt -> while_stmt .)
    INT_LIT         reduce using rule 32 (stmt -> while_stmt .)
    FALSE           reduce using rule 32 (stmt -> while_stmt .)
    TRUE            reduce using rule 32 (stmt -> while_stmt .)
    BOOL_LIT        reduce using rule 32 (stmt -> while_stmt .)
    IDENT           reduce using rule 32 (stmt -> while_stmt .)
    (               reduce using rule 32 (stmt -> while_stmt .)
    DEC             reduce using rule 32 (stmt -> while_stmt .)
    INC             reduce using rule 32 (stmt -> while_stmt .)
    PLUS            reduce using rule 32 (stmt -> while_stmt .)
    MINUS           reduce using rule 32 (stmt -> while_stmt .)
    !               reduce using rule 32 (stmt -> while_stmt .)
    ELSE            reduce using rule 32 (stmt -> while_stmt .)


state 128

    (33) stmt -> if_stmt .
    }               reduce using rule 33 (stmt -> if_stmt .)
    BREAK           reduce using rule 33 (stmt -> if_stmt .)
    RETURN          reduce using rule 33 (stmt -> if_stmt .)
    FOR             reduce using rule 33 (stmt -> if_stmt .)
    WHILE           reduce using rule 33 (stmt -> if_stmt .)
    IF              reduce using rule 33 (stmt -> if_stmt .)
    {               reduce using rule 33 (stmt -> if_stmt .)
    ;               reduce using rule 33 (stmt -> if_stmt .)
    NEW             reduce using rule 33 (stmt -> if_stmt .)
    STRING_LIT      reduce using rule 33 (stmt -> if_stmt .)
    CHAR_LIT        reduce using rule 33 (stmt -> if_stmt .)
    FLOAT_LIT       reduce using rule 33 (stmt -> if_stmt .)
    INT_LIT         reduce using rule 33 (stmt -> if_stmt .)
    FALSE           reduce using rule 33 (stmt -> if_stmt .)
    TRUE            reduce using rule 33 (stmt -> if_stmt .)
    BOOL_LIT        reduce using rule 33 (stmt -> if_stmt .)
    IDENT           reduce using rule 33 (stmt -> if_stmt .)
    (               reduce using rule 33 (stmt -> if_stmt .)
    DEC             reduce using rule 33 (stmt -> if_stmt .)
    INC             reduce using rule 33 (stmt -> if_stmt .)
    PLUS            reduce using rule 33 (stmt -> if_stmt .)
    MINUS           reduce using rule 33 (stmt -> if_stmt .)
    !               reduce using rule 33 (stmt -> if_stmt .)
    ELSE            reduce using rule 33 (stmt -> if_stmt .)


state 129

    (34) stmt -> compound_stmt .
    }               reduce using rule 34 (stmt -> compound_stmt .)
    BREAK           reduce using rule 34 (stmt -> compound_stmt .)
    RETURN          reduce using rule 34 (stmt -> compound_stmt .)
    FOR             reduce using rule 34 (stmt -> compound_stmt .)
    WHILE           reduce using rule 34 (stmt -> compound_stmt .)
    IF              reduce using rule 34 (stmt -> compound_stmt .)
    {               reduce using rule 34 (stmt -> compound_stmt .)
    ;               reduce using rule 34 (stmt -> compound_stmt .)
    NEW             reduce using rule 34 (stmt -> compound_stmt .)
    STRING_LIT      reduce using rule 34 (stmt -> compound_stmt .)
    CHAR_LIT        reduce using rule 34 (stmt -> compound_stmt .)
    FLOAT_LIT       reduce using rule 34 (stmt -> compound_stmt .)
    INT_LIT         reduce using rule 34 (stmt -> compound_stmt .)
    FALSE           reduce using rule 34 (stmt -> compound_stmt .)
    TRUE            reduce using rule 34 (stmt -> compound_stmt .)
    BOOL_LIT        reduce using rule 34 (stmt -> compound_stmt .)
    IDENT           reduce using rule 34 (stmt -> compound_stmt .)
    (               reduce using rule 34 (stmt -> compound_stmt .)
    DEC             reduce using rule 34 (stmt -> compound_stmt .)
    INC             reduce using rule 34 (stmt -> compound_stmt .)
    PLUS            reduce using rule 34 (stmt -> compound_stmt .)
    MINUS           reduce using rule 34 (stmt -> compound_stmt .)
    !               reduce using rule 34 (stmt -> compound_stmt .)
    ELSE            reduce using rule 34 (stmt -> compound_stmt .)


state 130

    (35) stmt -> expr_stmt .
    }               reduce using rule 35 (stmt -> expr_stmt .)
    BREAK           reduce using rule 35 (stmt -> expr_stmt .)
    RETURN          reduce using rule 35 (stmt -> expr_stmt .)
    FOR             reduce using rule 35 (stmt -> expr_stmt .)
    WHILE           reduce using rule 35 (stmt -> expr_stmt .)
    IF              reduce using rule 35 (stmt -> expr_stmt .)
    {               reduce using rule 35 (stmt -> expr_stmt .)
    ;               reduce using rule 35 (stmt -> expr_stmt .)
    NEW             reduce using rule 35 (stmt -> expr_stmt .)
    STRING_LIT      reduce using rule 35 (stmt -> expr_stmt .)
    CHAR_LIT        reduce using rule 35 (stmt -> expr_stmt .)
    FLOAT_LIT       reduce using rule 35 (stmt -> expr_stmt .)
    INT_LIT         reduce using rule 35 (stmt -> expr_stmt .)
    FALSE           reduce using rule 35 (stmt -> expr_stmt .)
    TRUE            reduce using rule 35 (stmt -> expr_stmt .)
    BOOL_LIT        reduce using rule 35 (stmt -> expr_stmt .)
    IDENT           reduce using rule 35 (stmt -> expr_stmt .)
    (               reduce using rule 35 (stmt -> expr_stmt .)
    DEC             reduce using rule 35 (stmt -> expr_stmt .)
    INC             reduce using rule 35 (stmt -> expr_stmt .)
    PLUS            reduce using rule 35 (stmt -> expr_stmt .)
    MINUS           reduce using rule 35 (stmt -> expr_stmt .)
    !               reduce using rule 35 (stmt -> expr_stmt .)
    ELSE            reduce using rule 35 (stmt -> expr_stmt .)


state 131

    (44) break_stmt -> BREAK . ;
    ;               shift and go to state 140


state 132

    (36) expr_stmt -> ; .
    }               reduce using rule 36 (expr_stmt -> ; .)
    BREAK           reduce using rule 36 (expr_stmt -> ; .)
    RETURN          reduce using rule 36 (expr_stmt -> ; .)
    FOR             reduce using rule 36 (expr_stmt -> ; .)
    WHILE           reduce using rule 36 (expr_stmt -> ; .)
    IF              reduce using rule 36 (expr_stmt -> ; .)
    {               reduce using rule 36 (expr_stmt -> ; .)
    ;               reduce using rule 36 (expr_stmt -> ; .)
    NEW             reduce using rule 36 (expr_stmt -> ; .)
    STRING_LIT      reduce using rule 36 (expr_stmt -> ; .)
    CHAR_LIT        reduce using rule 36 (expr_stmt -> ; .)
    FLOAT_LIT       reduce using rule 36 (expr_stmt -> ; .)
    INT_LIT         reduce using rule 36 (expr_stmt -> ; .)
    FALSE           reduce using rule 36 (expr_stmt -> ; .)
    TRUE            reduce using rule 36 (expr_stmt -> ; .)
    BOOL_LIT        reduce using rule 36 (expr_stmt -> ; .)
    IDENT           reduce using rule 36 (expr_stmt -> ; .)
    (               reduce using rule 36 (expr_stmt -> ; .)
    DEC             reduce using rule 36 (expr_stmt -> ; .)
    INC             reduce using rule 36 (expr_stmt -> ; .)
    PLUS            reduce using rule 36 (expr_stmt -> ; .)
    MINUS           reduce using rule 36 (expr_stmt -> ; .)
    !               reduce using rule 36 (expr_stmt -> ; .)
    ELSE            reduce using rule 36 (expr_stmt -> ; .)


state 133

    (42) return_stmt -> RETURN . expr ;
    (43) return_stmt -> RETURN . ;
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING_LIT
    (47) expr -> . CHAR_LIT
    (48) expr -> . FLOAT_LIT
    (49) expr -> . INT_LIT
    (50) expr -> . FALSE
    (51) expr -> . TRUE
    (52) expr -> . BOOL_LIT
    (53) expr -> . IDENT . SIZE
    (54) expr -> . IDENT ( args )
    (55) expr -> . IDENT [ expr ]
    (56) expr -> . IDENT
    (57) expr -> . ( expr )
    (58) expr -> . expr DEC
    (59) expr -> . expr INC
    (60) expr -> . DEC expr
    (61) expr -> . INC expr
    (62) expr -> . PLUS expr
    (63) expr -> . MINUS expr
    (64) expr -> . ! expr
    (65) expr -> . expr MOD expr
    (66) expr -> . expr DIVIDE expr
    (67) expr -> . expr TIMES expr
    (68) expr -> . expr MINUS expr
    (69) expr -> . expr PLUS expr
    (70) expr -> . expr > expr
    (71) expr -> . expr GE expr
    (72) expr -> . expr < expr
    (73) expr -> . expr LE expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT [ expr ] = expr
    (79) expr -> . IDENT MODASSIGN expr
    (80) expr -> . IDENT DIVASSIGN expr
    (81) expr -> . IDENT MULASSIGN expr
    (82) expr -> . IDENT SUBASSIGN expr
    (83) expr -> . IDENT ADDASSIGN expr
    (84) expr -> . IDENT = expr
    ;               shift and go to state 142
    NEW             shift and go to state 25
    STRING_LIT      shift and go to state 26
    CHAR_LIT        shift and go to state 27
    FLOAT_LIT       shift and go to state 28
    INT_LIT         shift and go to state 29
    FALSE           shift and go to state 30
    TRUE            shift and go to state 31
    BOOL_LIT        shift and go to state 32
    IDENT           shift and go to state 23
    (               shift and go to state 33
    DEC             shift and go to state 34
    INC             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    !               shift and go to state 38

    expr                           shift and go to state 141

state 134

    (37) expr_stmt -> expr . ;
    (58) expr -> expr . DEC
    (59) expr -> expr . INC
    (65) expr -> expr . MOD expr
    (66) expr -> expr . DIVIDE expr
    (67) expr -> expr . TIMES expr
    (68) expr -> expr . MINUS expr
    (69) expr -> expr . PLUS expr
    (70) expr -> expr . > expr
    (71) expr -> expr . GE expr
    (72) expr -> expr . < expr
    (73) expr -> expr . LE expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    ;               shift and go to state 143
    DEC             shift and go to state 53
    INC             shift and go to state 54
    MOD             shift and go to state 55
    DIVIDE          shift and go to state 56
    TIMES           shift and go to state 57
    MINUS           shift and go to state 58
    PLUS            shift and go to state 59
    >               shift and go to state 60
    GE              shift and go to state 61
    <               shift and go to state 62
    LE              shift and go to state 63
    NE              shift and go to state 64
    EQ              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 135

    (39) for_stmt -> FOR . ( args ; args ; args ) stmt
    (               shift and go to state 144


state 136

    (38) while_stmt -> WHILE . ( expr ) stmt
    (               shift and go to state 145


state 137

    (40) if_stmt -> IF . ( expr ) stmt ELSE stmt
    (41) if_stmt -> IF . ( expr ) stmt
    (               shift and go to state 146


state 138

    (24) local_decl -> type_spec IDENT . [ expr ] ;
    (25) local_decl -> type_spec IDENT . = expr ;
    (26) local_decl -> type_spec IDENT . ;
    [               shift and go to state 147
    =               shift and go to state 149
    ;               shift and go to state 148


state 139

    (78) expr -> IDENT [ expr ] = expr .
    (58) expr -> expr . DEC
    (59) expr -> expr . INC
    (65) expr -> expr . MOD expr
    (66) expr -> expr . DIVIDE expr
    (67) expr -> expr . TIMES expr
    (68) expr -> expr . MINUS expr
    (69) expr -> expr . PLUS expr
    (70) expr -> expr . > expr
    (71) expr -> expr . GE expr
    (72) expr -> expr . < expr
    (73) expr -> expr . LE expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    ]               reduce using rule 78 (expr -> IDENT [ expr ] = expr .)
    ;               reduce using rule 78 (expr -> IDENT [ expr ] = expr .)
    )               reduce using rule 78 (expr -> IDENT [ expr ] = expr .)
    ,               reduce using rule 78 (expr -> IDENT [ expr ] = expr .)
    DEC             shift and go to state 53
    INC             shift and go to state 54
    MOD             shift and go to state 55
    DIVIDE          shift and go to state 56
    TIMES           shift and go to state 57
    MINUS           shift and go to state 58
    PLUS            shift and go to state 59
    >               shift and go to state 60
    GE              shift and go to state 61
    <               shift and go to state 62
    LE              shift and go to state 63
    NE              shift and go to state 64
    EQ              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 140

    (44) break_stmt -> BREAK ; .
    }               reduce using rule 44 (break_stmt -> BREAK ; .)
    BREAK           reduce using rule 44 (break_stmt -> BREAK ; .)
    RETURN          reduce using rule 44 (break_stmt -> BREAK ; .)
    FOR             reduce using rule 44 (break_stmt -> BREAK ; .)
    WHILE           reduce using rule 44 (break_stmt -> BREAK ; .)
    IF              reduce using rule 44 (break_stmt -> BREAK ; .)
    {               reduce using rule 44 (break_stmt -> BREAK ; .)
    ;               reduce using rule 44 (break_stmt -> BREAK ; .)
    NEW             reduce using rule 44 (break_stmt -> BREAK ; .)
    STRING_LIT      reduce using rule 44 (break_stmt -> BREAK ; .)
    CHAR_LIT        reduce using rule 44 (break_stmt -> BREAK ; .)
    FLOAT_LIT       reduce using rule 44 (break_stmt -> BREAK ; .)
    INT_LIT         reduce using rule 44 (break_stmt -> BREAK ; .)
    FALSE           reduce using rule 44 (break_stmt -> BREAK ; .)
    TRUE            reduce using rule 44 (break_stmt -> BREAK ; .)
    BOOL_LIT        reduce using rule 44 (break_stmt -> BREAK ; .)
    IDENT           reduce using rule 44 (break_stmt -> BREAK ; .)
    (               reduce using rule 44 (break_stmt -> BREAK ; .)
    DEC             reduce using rule 44 (break_stmt -> BREAK ; .)
    INC             reduce using rule 44 (break_stmt -> BREAK ; .)
    PLUS            reduce using rule 44 (break_stmt -> BREAK ; .)
    MINUS           reduce using rule 44 (break_stmt -> BREAK ; .)
    !               reduce using rule 44 (break_stmt -> BREAK ; .)
    ELSE            reduce using rule 44 (break_stmt -> BREAK ; .)


state 141

    (42) return_stmt -> RETURN expr . ;
    (58) expr -> expr . DEC
    (59) expr -> expr . INC
    (65) expr -> expr . MOD expr
    (66) expr -> expr . DIVIDE expr
    (67) expr -> expr . TIMES expr
    (68) expr -> expr . MINUS expr
    (69) expr -> expr . PLUS expr
    (70) expr -> expr . > expr
    (71) expr -> expr . GE expr
    (72) expr -> expr . < expr
    (73) expr -> expr . LE expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    ;               shift and go to state 150
    DEC             shift and go to state 53
    INC             shift and go to state 54
    MOD             shift and go to state 55
    DIVIDE          shift and go to state 56
    TIMES           shift and go to state 57
    MINUS           shift and go to state 58
    PLUS            shift and go to state 59
    >               shift and go to state 60
    GE              shift and go to state 61
    <               shift and go to state 62
    LE              shift and go to state 63
    NE              shift and go to state 64
    EQ              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 142

    (43) return_stmt -> RETURN ; .
    }               reduce using rule 43 (return_stmt -> RETURN ; .)
    BREAK           reduce using rule 43 (return_stmt -> RETURN ; .)
    RETURN          reduce using rule 43 (return_stmt -> RETURN ; .)
    FOR             reduce using rule 43 (return_stmt -> RETURN ; .)
    WHILE           reduce using rule 43 (return_stmt -> RETURN ; .)
    IF              reduce using rule 43 (return_stmt -> RETURN ; .)
    {               reduce using rule 43 (return_stmt -> RETURN ; .)
    ;               reduce using rule 43 (return_stmt -> RETURN ; .)
    NEW             reduce using rule 43 (return_stmt -> RETURN ; .)
    STRING_LIT      reduce using rule 43 (return_stmt -> RETURN ; .)
    CHAR_LIT        reduce using rule 43 (return_stmt -> RETURN ; .)
    FLOAT_LIT       reduce using rule 43 (return_stmt -> RETURN ; .)
    INT_LIT         reduce using rule 43 (return_stmt -> RETURN ; .)
    FALSE           reduce using rule 43 (return_stmt -> RETURN ; .)
    TRUE            reduce using rule 43 (return_stmt -> RETURN ; .)
    BOOL_LIT        reduce using rule 43 (return_stmt -> RETURN ; .)
    IDENT           reduce using rule 43 (return_stmt -> RETURN ; .)
    (               reduce using rule 43 (return_stmt -> RETURN ; .)
    DEC             reduce using rule 43 (return_stmt -> RETURN ; .)
    INC             reduce using rule 43 (return_stmt -> RETURN ; .)
    PLUS            reduce using rule 43 (return_stmt -> RETURN ; .)
    MINUS           reduce using rule 43 (return_stmt -> RETURN ; .)
    !               reduce using rule 43 (return_stmt -> RETURN ; .)
    ELSE            reduce using rule 43 (return_stmt -> RETURN ; .)


state 143

    (37) expr_stmt -> expr ; .
    }               reduce using rule 37 (expr_stmt -> expr ; .)
    BREAK           reduce using rule 37 (expr_stmt -> expr ; .)
    RETURN          reduce using rule 37 (expr_stmt -> expr ; .)
    FOR             reduce using rule 37 (expr_stmt -> expr ; .)
    WHILE           reduce using rule 37 (expr_stmt -> expr ; .)
    IF              reduce using rule 37 (expr_stmt -> expr ; .)
    {               reduce using rule 37 (expr_stmt -> expr ; .)
    ;               reduce using rule 37 (expr_stmt -> expr ; .)
    NEW             reduce using rule 37 (expr_stmt -> expr ; .)
    STRING_LIT      reduce using rule 37 (expr_stmt -> expr ; .)
    CHAR_LIT        reduce using rule 37 (expr_stmt -> expr ; .)
    FLOAT_LIT       reduce using rule 37 (expr_stmt -> expr ; .)
    INT_LIT         reduce using rule 37 (expr_stmt -> expr ; .)
    FALSE           reduce using rule 37 (expr_stmt -> expr ; .)
    TRUE            reduce using rule 37 (expr_stmt -> expr ; .)
    BOOL_LIT        reduce using rule 37 (expr_stmt -> expr ; .)
    IDENT           reduce using rule 37 (expr_stmt -> expr ; .)
    (               reduce using rule 37 (expr_stmt -> expr ; .)
    DEC             reduce using rule 37 (expr_stmt -> expr ; .)
    INC             reduce using rule 37 (expr_stmt -> expr ; .)
    PLUS            reduce using rule 37 (expr_stmt -> expr ; .)
    MINUS           reduce using rule 37 (expr_stmt -> expr ; .)
    !               reduce using rule 37 (expr_stmt -> expr ; .)
    ELSE            reduce using rule 37 (expr_stmt -> expr ; .)


state 144

    (39) for_stmt -> FOR ( . args ; args ; args ) stmt
    (87) args -> . empty
    (88) args -> . arg_list
    (89) empty -> .
    (85) arg_list -> . expr
    (86) arg_list -> . arg_list , expr
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING_LIT
    (47) expr -> . CHAR_LIT
    (48) expr -> . FLOAT_LIT
    (49) expr -> . INT_LIT
    (50) expr -> . FALSE
    (51) expr -> . TRUE
    (52) expr -> . BOOL_LIT
    (53) expr -> . IDENT . SIZE
    (54) expr -> . IDENT ( args )
    (55) expr -> . IDENT [ expr ]
    (56) expr -> . IDENT
    (57) expr -> . ( expr )
    (58) expr -> . expr DEC
    (59) expr -> . expr INC
    (60) expr -> . DEC expr
    (61) expr -> . INC expr
    (62) expr -> . PLUS expr
    (63) expr -> . MINUS expr
    (64) expr -> . ! expr
    (65) expr -> . expr MOD expr
    (66) expr -> . expr DIVIDE expr
    (67) expr -> . expr TIMES expr
    (68) expr -> . expr MINUS expr
    (69) expr -> . expr PLUS expr
    (70) expr -> . expr > expr
    (71) expr -> . expr GE expr
    (72) expr -> . expr < expr
    (73) expr -> . expr LE expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT [ expr ] = expr
    (79) expr -> . IDENT MODASSIGN expr
    (80) expr -> . IDENT DIVASSIGN expr
    (81) expr -> . IDENT MULASSIGN expr
    (82) expr -> . IDENT SUBASSIGN expr
    (83) expr -> . IDENT ADDASSIGN expr
    (84) expr -> . IDENT = expr
    ;               reduce using rule 89 (empty -> .)
    NEW             shift and go to state 25
    STRING_LIT      shift and go to state 26
    CHAR_LIT        shift and go to state 27
    FLOAT_LIT       shift and go to state 28
    INT_LIT         shift and go to state 29
    FALSE           shift and go to state 30
    TRUE            shift and go to state 31
    BOOL_LIT        shift and go to state 32
    IDENT           shift and go to state 23
    (               shift and go to state 33
    DEC             shift and go to state 34
    INC             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    !               shift and go to state 38

    args                           shift and go to state 151
    empty                          shift and go to state 82
    arg_list                       shift and go to state 83
    expr                           shift and go to state 84

state 145

    (38) while_stmt -> WHILE ( . expr ) stmt
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING_LIT
    (47) expr -> . CHAR_LIT
    (48) expr -> . FLOAT_LIT
    (49) expr -> . INT_LIT
    (50) expr -> . FALSE
    (51) expr -> . TRUE
    (52) expr -> . BOOL_LIT
    (53) expr -> . IDENT . SIZE
    (54) expr -> . IDENT ( args )
    (55) expr -> . IDENT [ expr ]
    (56) expr -> . IDENT
    (57) expr -> . ( expr )
    (58) expr -> . expr DEC
    (59) expr -> . expr INC
    (60) expr -> . DEC expr
    (61) expr -> . INC expr
    (62) expr -> . PLUS expr
    (63) expr -> . MINUS expr
    (64) expr -> . ! expr
    (65) expr -> . expr MOD expr
    (66) expr -> . expr DIVIDE expr
    (67) expr -> . expr TIMES expr
    (68) expr -> . expr MINUS expr
    (69) expr -> . expr PLUS expr
    (70) expr -> . expr > expr
    (71) expr -> . expr GE expr
    (72) expr -> . expr < expr
    (73) expr -> . expr LE expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT [ expr ] = expr
    (79) expr -> . IDENT MODASSIGN expr
    (80) expr -> . IDENT DIVASSIGN expr
    (81) expr -> . IDENT MULASSIGN expr
    (82) expr -> . IDENT SUBASSIGN expr
    (83) expr -> . IDENT ADDASSIGN expr
    (84) expr -> . IDENT = expr
    NEW             shift and go to state 25
    STRING_LIT      shift and go to state 26
    CHAR_LIT        shift and go to state 27
    FLOAT_LIT       shift and go to state 28
    INT_LIT         shift and go to state 29
    FALSE           shift and go to state 30
    TRUE            shift and go to state 31
    BOOL_LIT        shift and go to state 32
    IDENT           shift and go to state 23
    (               shift and go to state 33
    DEC             shift and go to state 34
    INC             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    !               shift and go to state 38

    expr                           shift and go to state 152

state 146

    (40) if_stmt -> IF ( . expr ) stmt ELSE stmt
    (41) if_stmt -> IF ( . expr ) stmt
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING_LIT
    (47) expr -> . CHAR_LIT
    (48) expr -> . FLOAT_LIT
    (49) expr -> . INT_LIT
    (50) expr -> . FALSE
    (51) expr -> . TRUE
    (52) expr -> . BOOL_LIT
    (53) expr -> . IDENT . SIZE
    (54) expr -> . IDENT ( args )
    (55) expr -> . IDENT [ expr ]
    (56) expr -> . IDENT
    (57) expr -> . ( expr )
    (58) expr -> . expr DEC
    (59) expr -> . expr INC
    (60) expr -> . DEC expr
    (61) expr -> . INC expr
    (62) expr -> . PLUS expr
    (63) expr -> . MINUS expr
    (64) expr -> . ! expr
    (65) expr -> . expr MOD expr
    (66) expr -> . expr DIVIDE expr
    (67) expr -> . expr TIMES expr
    (68) expr -> . expr MINUS expr
    (69) expr -> . expr PLUS expr
    (70) expr -> . expr > expr
    (71) expr -> . expr GE expr
    (72) expr -> . expr < expr
    (73) expr -> . expr LE expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT [ expr ] = expr
    (79) expr -> . IDENT MODASSIGN expr
    (80) expr -> . IDENT DIVASSIGN expr
    (81) expr -> . IDENT MULASSIGN expr
    (82) expr -> . IDENT SUBASSIGN expr
    (83) expr -> . IDENT ADDASSIGN expr
    (84) expr -> . IDENT = expr
    NEW             shift and go to state 25
    STRING_LIT      shift and go to state 26
    CHAR_LIT        shift and go to state 27
    FLOAT_LIT       shift and go to state 28
    INT_LIT         shift and go to state 29
    FALSE           shift and go to state 30
    TRUE            shift and go to state 31
    BOOL_LIT        shift and go to state 32
    IDENT           shift and go to state 23
    (               shift and go to state 33
    DEC             shift and go to state 34
    INC             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    !               shift and go to state 38

    expr                           shift and go to state 153

state 147

    (24) local_decl -> type_spec IDENT [ . expr ] ;
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING_LIT
    (47) expr -> . CHAR_LIT
    (48) expr -> . FLOAT_LIT
    (49) expr -> . INT_LIT
    (50) expr -> . FALSE
    (51) expr -> . TRUE
    (52) expr -> . BOOL_LIT
    (53) expr -> . IDENT . SIZE
    (54) expr -> . IDENT ( args )
    (55) expr -> . IDENT [ expr ]
    (56) expr -> . IDENT
    (57) expr -> . ( expr )
    (58) expr -> . expr DEC
    (59) expr -> . expr INC
    (60) expr -> . DEC expr
    (61) expr -> . INC expr
    (62) expr -> . PLUS expr
    (63) expr -> . MINUS expr
    (64) expr -> . ! expr
    (65) expr -> . expr MOD expr
    (66) expr -> . expr DIVIDE expr
    (67) expr -> . expr TIMES expr
    (68) expr -> . expr MINUS expr
    (69) expr -> . expr PLUS expr
    (70) expr -> . expr > expr
    (71) expr -> . expr GE expr
    (72) expr -> . expr < expr
    (73) expr -> . expr LE expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT [ expr ] = expr
    (79) expr -> . IDENT MODASSIGN expr
    (80) expr -> . IDENT DIVASSIGN expr
    (81) expr -> . IDENT MULASSIGN expr
    (82) expr -> . IDENT SUBASSIGN expr
    (83) expr -> . IDENT ADDASSIGN expr
    (84) expr -> . IDENT = expr
    NEW             shift and go to state 25
    STRING_LIT      shift and go to state 26
    CHAR_LIT        shift and go to state 27
    FLOAT_LIT       shift and go to state 28
    INT_LIT         shift and go to state 29
    FALSE           shift and go to state 30
    TRUE            shift and go to state 31
    BOOL_LIT        shift and go to state 32
    IDENT           shift and go to state 23
    (               shift and go to state 33
    DEC             shift and go to state 34
    INC             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    !               shift and go to state 38

    expr                           shift and go to state 154

state 148

    (26) local_decl -> type_spec IDENT ; .
    CHAR            reduce using rule 26 (local_decl -> type_spec IDENT ; .)
    FLOAT           reduce using rule 26 (local_decl -> type_spec IDENT ; .)
    INT             reduce using rule 26 (local_decl -> type_spec IDENT ; .)
    BOOL            reduce using rule 26 (local_decl -> type_spec IDENT ; .)
    VOID            reduce using rule 26 (local_decl -> type_spec IDENT ; .)
    }               reduce using rule 26 (local_decl -> type_spec IDENT ; .)
    BREAK           reduce using rule 26 (local_decl -> type_spec IDENT ; .)
    RETURN          reduce using rule 26 (local_decl -> type_spec IDENT ; .)
    FOR             reduce using rule 26 (local_decl -> type_spec IDENT ; .)
    WHILE           reduce using rule 26 (local_decl -> type_spec IDENT ; .)
    IF              reduce using rule 26 (local_decl -> type_spec IDENT ; .)
    {               reduce using rule 26 (local_decl -> type_spec IDENT ; .)
    ;               reduce using rule 26 (local_decl -> type_spec IDENT ; .)
    NEW             reduce using rule 26 (local_decl -> type_spec IDENT ; .)
    STRING_LIT      reduce using rule 26 (local_decl -> type_spec IDENT ; .)
    CHAR_LIT        reduce using rule 26 (local_decl -> type_spec IDENT ; .)
    FLOAT_LIT       reduce using rule 26 (local_decl -> type_spec IDENT ; .)
    INT_LIT         reduce using rule 26 (local_decl -> type_spec IDENT ; .)
    FALSE           reduce using rule 26 (local_decl -> type_spec IDENT ; .)
    TRUE            reduce using rule 26 (local_decl -> type_spec IDENT ; .)
    BOOL_LIT        reduce using rule 26 (local_decl -> type_spec IDENT ; .)
    IDENT           reduce using rule 26 (local_decl -> type_spec IDENT ; .)
    (               reduce using rule 26 (local_decl -> type_spec IDENT ; .)
    DEC             reduce using rule 26 (local_decl -> type_spec IDENT ; .)
    INC             reduce using rule 26 (local_decl -> type_spec IDENT ; .)
    PLUS            reduce using rule 26 (local_decl -> type_spec IDENT ; .)
    MINUS           reduce using rule 26 (local_decl -> type_spec IDENT ; .)
    !               reduce using rule 26 (local_decl -> type_spec IDENT ; .)


state 149

    (25) local_decl -> type_spec IDENT = . expr ;
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING_LIT
    (47) expr -> . CHAR_LIT
    (48) expr -> . FLOAT_LIT
    (49) expr -> . INT_LIT
    (50) expr -> . FALSE
    (51) expr -> . TRUE
    (52) expr -> . BOOL_LIT
    (53) expr -> . IDENT . SIZE
    (54) expr -> . IDENT ( args )
    (55) expr -> . IDENT [ expr ]
    (56) expr -> . IDENT
    (57) expr -> . ( expr )
    (58) expr -> . expr DEC
    (59) expr -> . expr INC
    (60) expr -> . DEC expr
    (61) expr -> . INC expr
    (62) expr -> . PLUS expr
    (63) expr -> . MINUS expr
    (64) expr -> . ! expr
    (65) expr -> . expr MOD expr
    (66) expr -> . expr DIVIDE expr
    (67) expr -> . expr TIMES expr
    (68) expr -> . expr MINUS expr
    (69) expr -> . expr PLUS expr
    (70) expr -> . expr > expr
    (71) expr -> . expr GE expr
    (72) expr -> . expr < expr
    (73) expr -> . expr LE expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT [ expr ] = expr
    (79) expr -> . IDENT MODASSIGN expr
    (80) expr -> . IDENT DIVASSIGN expr
    (81) expr -> . IDENT MULASSIGN expr
    (82) expr -> . IDENT SUBASSIGN expr
    (83) expr -> . IDENT ADDASSIGN expr
    (84) expr -> . IDENT = expr
    NEW             shift and go to state 25
    STRING_LIT      shift and go to state 26
    CHAR_LIT        shift and go to state 27
    FLOAT_LIT       shift and go to state 28
    INT_LIT         shift and go to state 29
    FALSE           shift and go to state 30
    TRUE            shift and go to state 31
    BOOL_LIT        shift and go to state 32
    IDENT           shift and go to state 23
    (               shift and go to state 33
    DEC             shift and go to state 34
    INC             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    !               shift and go to state 38

    expr                           shift and go to state 155

state 150

    (42) return_stmt -> RETURN expr ; .
    }               reduce using rule 42 (return_stmt -> RETURN expr ; .)
    BREAK           reduce using rule 42 (return_stmt -> RETURN expr ; .)
    RETURN          reduce using rule 42 (return_stmt -> RETURN expr ; .)
    FOR             reduce using rule 42 (return_stmt -> RETURN expr ; .)
    WHILE           reduce using rule 42 (return_stmt -> RETURN expr ; .)
    IF              reduce using rule 42 (return_stmt -> RETURN expr ; .)
    {               reduce using rule 42 (return_stmt -> RETURN expr ; .)
    ;               reduce using rule 42 (return_stmt -> RETURN expr ; .)
    NEW             reduce using rule 42 (return_stmt -> RETURN expr ; .)
    STRING_LIT      reduce using rule 42 (return_stmt -> RETURN expr ; .)
    CHAR_LIT        reduce using rule 42 (return_stmt -> RETURN expr ; .)
    FLOAT_LIT       reduce using rule 42 (return_stmt -> RETURN expr ; .)
    INT_LIT         reduce using rule 42 (return_stmt -> RETURN expr ; .)
    FALSE           reduce using rule 42 (return_stmt -> RETURN expr ; .)
    TRUE            reduce using rule 42 (return_stmt -> RETURN expr ; .)
    BOOL_LIT        reduce using rule 42 (return_stmt -> RETURN expr ; .)
    IDENT           reduce using rule 42 (return_stmt -> RETURN expr ; .)
    (               reduce using rule 42 (return_stmt -> RETURN expr ; .)
    DEC             reduce using rule 42 (return_stmt -> RETURN expr ; .)
    INC             reduce using rule 42 (return_stmt -> RETURN expr ; .)
    PLUS            reduce using rule 42 (return_stmt -> RETURN expr ; .)
    MINUS           reduce using rule 42 (return_stmt -> RETURN expr ; .)
    !               reduce using rule 42 (return_stmt -> RETURN expr ; .)
    ELSE            reduce using rule 42 (return_stmt -> RETURN expr ; .)


state 151

    (39) for_stmt -> FOR ( args . ; args ; args ) stmt
    ;               shift and go to state 156


state 152

    (38) while_stmt -> WHILE ( expr . ) stmt
    (58) expr -> expr . DEC
    (59) expr -> expr . INC
    (65) expr -> expr . MOD expr
    (66) expr -> expr . DIVIDE expr
    (67) expr -> expr . TIMES expr
    (68) expr -> expr . MINUS expr
    (69) expr -> expr . PLUS expr
    (70) expr -> expr . > expr
    (71) expr -> expr . GE expr
    (72) expr -> expr . < expr
    (73) expr -> expr . LE expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    )               shift and go to state 157
    DEC             shift and go to state 53
    INC             shift and go to state 54
    MOD             shift and go to state 55
    DIVIDE          shift and go to state 56
    TIMES           shift and go to state 57
    MINUS           shift and go to state 58
    PLUS            shift and go to state 59
    >               shift and go to state 60
    GE              shift and go to state 61
    <               shift and go to state 62
    LE              shift and go to state 63
    NE              shift and go to state 64
    EQ              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 153

    (40) if_stmt -> IF ( expr . ) stmt ELSE stmt
    (41) if_stmt -> IF ( expr . ) stmt
    (58) expr -> expr . DEC
    (59) expr -> expr . INC
    (65) expr -> expr . MOD expr
    (66) expr -> expr . DIVIDE expr
    (67) expr -> expr . TIMES expr
    (68) expr -> expr . MINUS expr
    (69) expr -> expr . PLUS expr
    (70) expr -> expr . > expr
    (71) expr -> expr . GE expr
    (72) expr -> expr . < expr
    (73) expr -> expr . LE expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    )               shift and go to state 158
    DEC             shift and go to state 53
    INC             shift and go to state 54
    MOD             shift and go to state 55
    DIVIDE          shift and go to state 56
    TIMES           shift and go to state 57
    MINUS           shift and go to state 58
    PLUS            shift and go to state 59
    >               shift and go to state 60
    GE              shift and go to state 61
    <               shift and go to state 62
    LE              shift and go to state 63
    NE              shift and go to state 64
    EQ              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 154

    (24) local_decl -> type_spec IDENT [ expr . ] ;
    (58) expr -> expr . DEC
    (59) expr -> expr . INC
    (65) expr -> expr . MOD expr
    (66) expr -> expr . DIVIDE expr
    (67) expr -> expr . TIMES expr
    (68) expr -> expr . MINUS expr
    (69) expr -> expr . PLUS expr
    (70) expr -> expr . > expr
    (71) expr -> expr . GE expr
    (72) expr -> expr . < expr
    (73) expr -> expr . LE expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    ]               shift and go to state 159
    DEC             shift and go to state 53
    INC             shift and go to state 54
    MOD             shift and go to state 55
    DIVIDE          shift and go to state 56
    TIMES           shift and go to state 57
    MINUS           shift and go to state 58
    PLUS            shift and go to state 59
    >               shift and go to state 60
    GE              shift and go to state 61
    <               shift and go to state 62
    LE              shift and go to state 63
    NE              shift and go to state 64
    EQ              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 155

    (25) local_decl -> type_spec IDENT = expr . ;
    (58) expr -> expr . DEC
    (59) expr -> expr . INC
    (65) expr -> expr . MOD expr
    (66) expr -> expr . DIVIDE expr
    (67) expr -> expr . TIMES expr
    (68) expr -> expr . MINUS expr
    (69) expr -> expr . PLUS expr
    (70) expr -> expr . > expr
    (71) expr -> expr . GE expr
    (72) expr -> expr . < expr
    (73) expr -> expr . LE expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    ;               shift and go to state 160
    DEC             shift and go to state 53
    INC             shift and go to state 54
    MOD             shift and go to state 55
    DIVIDE          shift and go to state 56
    TIMES           shift and go to state 57
    MINUS           shift and go to state 58
    PLUS            shift and go to state 59
    >               shift and go to state 60
    GE              shift and go to state 61
    <               shift and go to state 62
    LE              shift and go to state 63
    NE              shift and go to state 64
    EQ              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 156

    (39) for_stmt -> FOR ( args ; . args ; args ) stmt
    (87) args -> . empty
    (88) args -> . arg_list
    (89) empty -> .
    (85) arg_list -> . expr
    (86) arg_list -> . arg_list , expr
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING_LIT
    (47) expr -> . CHAR_LIT
    (48) expr -> . FLOAT_LIT
    (49) expr -> . INT_LIT
    (50) expr -> . FALSE
    (51) expr -> . TRUE
    (52) expr -> . BOOL_LIT
    (53) expr -> . IDENT . SIZE
    (54) expr -> . IDENT ( args )
    (55) expr -> . IDENT [ expr ]
    (56) expr -> . IDENT
    (57) expr -> . ( expr )
    (58) expr -> . expr DEC
    (59) expr -> . expr INC
    (60) expr -> . DEC expr
    (61) expr -> . INC expr
    (62) expr -> . PLUS expr
    (63) expr -> . MINUS expr
    (64) expr -> . ! expr
    (65) expr -> . expr MOD expr
    (66) expr -> . expr DIVIDE expr
    (67) expr -> . expr TIMES expr
    (68) expr -> . expr MINUS expr
    (69) expr -> . expr PLUS expr
    (70) expr -> . expr > expr
    (71) expr -> . expr GE expr
    (72) expr -> . expr < expr
    (73) expr -> . expr LE expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT [ expr ] = expr
    (79) expr -> . IDENT MODASSIGN expr
    (80) expr -> . IDENT DIVASSIGN expr
    (81) expr -> . IDENT MULASSIGN expr
    (82) expr -> . IDENT SUBASSIGN expr
    (83) expr -> . IDENT ADDASSIGN expr
    (84) expr -> . IDENT = expr
    ;               reduce using rule 89 (empty -> .)
    NEW             shift and go to state 25
    STRING_LIT      shift and go to state 26
    CHAR_LIT        shift and go to state 27
    FLOAT_LIT       shift and go to state 28
    INT_LIT         shift and go to state 29
    FALSE           shift and go to state 30
    TRUE            shift and go to state 31
    BOOL_LIT        shift and go to state 32
    IDENT           shift and go to state 23
    (               shift and go to state 33
    DEC             shift and go to state 34
    INC             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    !               shift and go to state 38

    args                           shift and go to state 161
    empty                          shift and go to state 82
    arg_list                       shift and go to state 83
    expr                           shift and go to state 84

state 157

    (38) while_stmt -> WHILE ( expr ) . stmt
    (29) stmt -> . break_stmt
    (30) stmt -> . return_stmt
    (31) stmt -> . for_stmt
    (32) stmt -> . while_stmt
    (33) stmt -> . if_stmt
    (34) stmt -> . compound_stmt
    (35) stmt -> . expr_stmt
    (44) break_stmt -> . BREAK ;
    (42) return_stmt -> . RETURN expr ;
    (43) return_stmt -> . RETURN ;
    (39) for_stmt -> . FOR ( args ; args ; args ) stmt
    (38) while_stmt -> . WHILE ( expr ) stmt
    (40) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (41) if_stmt -> . IF ( expr ) stmt
    (21) compound_stmt -> . { local_decls stmt_list }
    (36) expr_stmt -> . ;
    (37) expr_stmt -> . expr ;
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING_LIT
    (47) expr -> . CHAR_LIT
    (48) expr -> . FLOAT_LIT
    (49) expr -> . INT_LIT
    (50) expr -> . FALSE
    (51) expr -> . TRUE
    (52) expr -> . BOOL_LIT
    (53) expr -> . IDENT . SIZE
    (54) expr -> . IDENT ( args )
    (55) expr -> . IDENT [ expr ]
    (56) expr -> . IDENT
    (57) expr -> . ( expr )
    (58) expr -> . expr DEC
    (59) expr -> . expr INC
    (60) expr -> . DEC expr
    (61) expr -> . INC expr
    (62) expr -> . PLUS expr
    (63) expr -> . MINUS expr
    (64) expr -> . ! expr
    (65) expr -> . expr MOD expr
    (66) expr -> . expr DIVIDE expr
    (67) expr -> . expr TIMES expr
    (68) expr -> . expr MINUS expr
    (69) expr -> . expr PLUS expr
    (70) expr -> . expr > expr
    (71) expr -> . expr GE expr
    (72) expr -> . expr < expr
    (73) expr -> . expr LE expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT [ expr ] = expr
    (79) expr -> . IDENT MODASSIGN expr
    (80) expr -> . IDENT DIVASSIGN expr
    (81) expr -> . IDENT MULASSIGN expr
    (82) expr -> . IDENT SUBASSIGN expr
    (83) expr -> . IDENT ADDASSIGN expr
    (84) expr -> . IDENT = expr
    BREAK           shift and go to state 131
    RETURN          shift and go to state 133
    FOR             shift and go to state 135
    WHILE           shift and go to state 136
    IF              shift and go to state 137
    {               shift and go to state 78
    ;               shift and go to state 132
    NEW             shift and go to state 25
    STRING_LIT      shift and go to state 26
    CHAR_LIT        shift and go to state 27
    FLOAT_LIT       shift and go to state 28
    INT_LIT         shift and go to state 29
    FALSE           shift and go to state 30
    TRUE            shift and go to state 31
    BOOL_LIT        shift and go to state 32
    IDENT           shift and go to state 23
    (               shift and go to state 33
    DEC             shift and go to state 34
    INC             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    !               shift and go to state 38

    expr                           shift and go to state 134
    stmt                           shift and go to state 162
    break_stmt                     shift and go to state 124
    return_stmt                    shift and go to state 125
    for_stmt                       shift and go to state 126
    while_stmt                     shift and go to state 127
    if_stmt                        shift and go to state 128
    compound_stmt                  shift and go to state 129
    expr_stmt                      shift and go to state 130

state 158

    (40) if_stmt -> IF ( expr ) . stmt ELSE stmt
    (41) if_stmt -> IF ( expr ) . stmt
    (29) stmt -> . break_stmt
    (30) stmt -> . return_stmt
    (31) stmt -> . for_stmt
    (32) stmt -> . while_stmt
    (33) stmt -> . if_stmt
    (34) stmt -> . compound_stmt
    (35) stmt -> . expr_stmt
    (44) break_stmt -> . BREAK ;
    (42) return_stmt -> . RETURN expr ;
    (43) return_stmt -> . RETURN ;
    (39) for_stmt -> . FOR ( args ; args ; args ) stmt
    (38) while_stmt -> . WHILE ( expr ) stmt
    (40) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (41) if_stmt -> . IF ( expr ) stmt
    (21) compound_stmt -> . { local_decls stmt_list }
    (36) expr_stmt -> . ;
    (37) expr_stmt -> . expr ;
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING_LIT
    (47) expr -> . CHAR_LIT
    (48) expr -> . FLOAT_LIT
    (49) expr -> . INT_LIT
    (50) expr -> . FALSE
    (51) expr -> . TRUE
    (52) expr -> . BOOL_LIT
    (53) expr -> . IDENT . SIZE
    (54) expr -> . IDENT ( args )
    (55) expr -> . IDENT [ expr ]
    (56) expr -> . IDENT
    (57) expr -> . ( expr )
    (58) expr -> . expr DEC
    (59) expr -> . expr INC
    (60) expr -> . DEC expr
    (61) expr -> . INC expr
    (62) expr -> . PLUS expr
    (63) expr -> . MINUS expr
    (64) expr -> . ! expr
    (65) expr -> . expr MOD expr
    (66) expr -> . expr DIVIDE expr
    (67) expr -> . expr TIMES expr
    (68) expr -> . expr MINUS expr
    (69) expr -> . expr PLUS expr
    (70) expr -> . expr > expr
    (71) expr -> . expr GE expr
    (72) expr -> . expr < expr
    (73) expr -> . expr LE expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT [ expr ] = expr
    (79) expr -> . IDENT MODASSIGN expr
    (80) expr -> . IDENT DIVASSIGN expr
    (81) expr -> . IDENT MULASSIGN expr
    (82) expr -> . IDENT SUBASSIGN expr
    (83) expr -> . IDENT ADDASSIGN expr
    (84) expr -> . IDENT = expr
    BREAK           shift and go to state 131
    RETURN          shift and go to state 133
    FOR             shift and go to state 135
    WHILE           shift and go to state 136
    IF              shift and go to state 137
    {               shift and go to state 78
    ;               shift and go to state 132
    NEW             shift and go to state 25
    STRING_LIT      shift and go to state 26
    CHAR_LIT        shift and go to state 27
    FLOAT_LIT       shift and go to state 28
    INT_LIT         shift and go to state 29
    FALSE           shift and go to state 30
    TRUE            shift and go to state 31
    BOOL_LIT        shift and go to state 32
    IDENT           shift and go to state 23
    (               shift and go to state 33
    DEC             shift and go to state 34
    INC             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    !               shift and go to state 38

    expr                           shift and go to state 134
    stmt                           shift and go to state 163
    break_stmt                     shift and go to state 124
    return_stmt                    shift and go to state 125
    for_stmt                       shift and go to state 126
    while_stmt                     shift and go to state 127
    if_stmt                        shift and go to state 128
    compound_stmt                  shift and go to state 129
    expr_stmt                      shift and go to state 130

state 159

    (24) local_decl -> type_spec IDENT [ expr ] . ;
    ;               shift and go to state 164


state 160

    (25) local_decl -> type_spec IDENT = expr ; .
    CHAR            reduce using rule 25 (local_decl -> type_spec IDENT = expr ; .)
    FLOAT           reduce using rule 25 (local_decl -> type_spec IDENT = expr ; .)
    INT             reduce using rule 25 (local_decl -> type_spec IDENT = expr ; .)
    BOOL            reduce using rule 25 (local_decl -> type_spec IDENT = expr ; .)
    VOID            reduce using rule 25 (local_decl -> type_spec IDENT = expr ; .)
    }               reduce using rule 25 (local_decl -> type_spec IDENT = expr ; .)
    BREAK           reduce using rule 25 (local_decl -> type_spec IDENT = expr ; .)
    RETURN          reduce using rule 25 (local_decl -> type_spec IDENT = expr ; .)
    FOR             reduce using rule 25 (local_decl -> type_spec IDENT = expr ; .)
    WHILE           reduce using rule 25 (local_decl -> type_spec IDENT = expr ; .)
    IF              reduce using rule 25 (local_decl -> type_spec IDENT = expr ; .)
    {               reduce using rule 25 (local_decl -> type_spec IDENT = expr ; .)
    ;               reduce using rule 25 (local_decl -> type_spec IDENT = expr ; .)
    NEW             reduce using rule 25 (local_decl -> type_spec IDENT = expr ; .)
    STRING_LIT      reduce using rule 25 (local_decl -> type_spec IDENT = expr ; .)
    CHAR_LIT        reduce using rule 25 (local_decl -> type_spec IDENT = expr ; .)
    FLOAT_LIT       reduce using rule 25 (local_decl -> type_spec IDENT = expr ; .)
    INT_LIT         reduce using rule 25 (local_decl -> type_spec IDENT = expr ; .)
    FALSE           reduce using rule 25 (local_decl -> type_spec IDENT = expr ; .)
    TRUE            reduce using rule 25 (local_decl -> type_spec IDENT = expr ; .)
    BOOL_LIT        reduce using rule 25 (local_decl -> type_spec IDENT = expr ; .)
    IDENT           reduce using rule 25 (local_decl -> type_spec IDENT = expr ; .)
    (               reduce using rule 25 (local_decl -> type_spec IDENT = expr ; .)
    DEC             reduce using rule 25 (local_decl -> type_spec IDENT = expr ; .)
    INC             reduce using rule 25 (local_decl -> type_spec IDENT = expr ; .)
    PLUS            reduce using rule 25 (local_decl -> type_spec IDENT = expr ; .)
    MINUS           reduce using rule 25 (local_decl -> type_spec IDENT = expr ; .)
    !               reduce using rule 25 (local_decl -> type_spec IDENT = expr ; .)


state 161

    (39) for_stmt -> FOR ( args ; args . ; args ) stmt
    ;               shift and go to state 165


state 162

    (38) while_stmt -> WHILE ( expr ) stmt .
    }               reduce using rule 38 (while_stmt -> WHILE ( expr ) stmt .)
    BREAK           reduce using rule 38 (while_stmt -> WHILE ( expr ) stmt .)
    RETURN          reduce using rule 38 (while_stmt -> WHILE ( expr ) stmt .)
    FOR             reduce using rule 38 (while_stmt -> WHILE ( expr ) stmt .)
    WHILE           reduce using rule 38 (while_stmt -> WHILE ( expr ) stmt .)
    IF              reduce using rule 38 (while_stmt -> WHILE ( expr ) stmt .)
    {               reduce using rule 38 (while_stmt -> WHILE ( expr ) stmt .)
    ;               reduce using rule 38 (while_stmt -> WHILE ( expr ) stmt .)
    NEW             reduce using rule 38 (while_stmt -> WHILE ( expr ) stmt .)
    STRING_LIT      reduce using rule 38 (while_stmt -> WHILE ( expr ) stmt .)
    CHAR_LIT        reduce using rule 38 (while_stmt -> WHILE ( expr ) stmt .)
    FLOAT_LIT       reduce using rule 38 (while_stmt -> WHILE ( expr ) stmt .)
    INT_LIT         reduce using rule 38 (while_stmt -> WHILE ( expr ) stmt .)
    FALSE           reduce using rule 38 (while_stmt -> WHILE ( expr ) stmt .)
    TRUE            reduce using rule 38 (while_stmt -> WHILE ( expr ) stmt .)
    BOOL_LIT        reduce using rule 38 (while_stmt -> WHILE ( expr ) stmt .)
    IDENT           reduce using rule 38 (while_stmt -> WHILE ( expr ) stmt .)
    (               reduce using rule 38 (while_stmt -> WHILE ( expr ) stmt .)
    DEC             reduce using rule 38 (while_stmt -> WHILE ( expr ) stmt .)
    INC             reduce using rule 38 (while_stmt -> WHILE ( expr ) stmt .)
    PLUS            reduce using rule 38 (while_stmt -> WHILE ( expr ) stmt .)
    MINUS           reduce using rule 38 (while_stmt -> WHILE ( expr ) stmt .)
    !               reduce using rule 38 (while_stmt -> WHILE ( expr ) stmt .)
    ELSE            reduce using rule 38 (while_stmt -> WHILE ( expr ) stmt .)


state 163

    (40) if_stmt -> IF ( expr ) stmt . ELSE stmt
    (41) if_stmt -> IF ( expr ) stmt .
    ELSE            shift and go to state 166
    }               reduce using rule 41 (if_stmt -> IF ( expr ) stmt .)
    BREAK           reduce using rule 41 (if_stmt -> IF ( expr ) stmt .)
    RETURN          reduce using rule 41 (if_stmt -> IF ( expr ) stmt .)
    FOR             reduce using rule 41 (if_stmt -> IF ( expr ) stmt .)
    WHILE           reduce using rule 41 (if_stmt -> IF ( expr ) stmt .)
    IF              reduce using rule 41 (if_stmt -> IF ( expr ) stmt .)
    {               reduce using rule 41 (if_stmt -> IF ( expr ) stmt .)
    ;               reduce using rule 41 (if_stmt -> IF ( expr ) stmt .)
    NEW             reduce using rule 41 (if_stmt -> IF ( expr ) stmt .)
    STRING_LIT      reduce using rule 41 (if_stmt -> IF ( expr ) stmt .)
    CHAR_LIT        reduce using rule 41 (if_stmt -> IF ( expr ) stmt .)
    FLOAT_LIT       reduce using rule 41 (if_stmt -> IF ( expr ) stmt .)
    INT_LIT         reduce using rule 41 (if_stmt -> IF ( expr ) stmt .)
    FALSE           reduce using rule 41 (if_stmt -> IF ( expr ) stmt .)
    TRUE            reduce using rule 41 (if_stmt -> IF ( expr ) stmt .)
    BOOL_LIT        reduce using rule 41 (if_stmt -> IF ( expr ) stmt .)
    IDENT           reduce using rule 41 (if_stmt -> IF ( expr ) stmt .)
    (               reduce using rule 41 (if_stmt -> IF ( expr ) stmt .)
    DEC             reduce using rule 41 (if_stmt -> IF ( expr ) stmt .)
    INC             reduce using rule 41 (if_stmt -> IF ( expr ) stmt .)
    PLUS            reduce using rule 41 (if_stmt -> IF ( expr ) stmt .)
    MINUS           reduce using rule 41 (if_stmt -> IF ( expr ) stmt .)
    !               reduce using rule 41 (if_stmt -> IF ( expr ) stmt .)


state 164

    (24) local_decl -> type_spec IDENT [ expr ] ; .
    CHAR            reduce using rule 24 (local_decl -> type_spec IDENT [ expr ] ; .)
    FLOAT           reduce using rule 24 (local_decl -> type_spec IDENT [ expr ] ; .)
    INT             reduce using rule 24 (local_decl -> type_spec IDENT [ expr ] ; .)
    BOOL            reduce using rule 24 (local_decl -> type_spec IDENT [ expr ] ; .)
    VOID            reduce using rule 24 (local_decl -> type_spec IDENT [ expr ] ; .)
    }               reduce using rule 24 (local_decl -> type_spec IDENT [ expr ] ; .)
    BREAK           reduce using rule 24 (local_decl -> type_spec IDENT [ expr ] ; .)
    RETURN          reduce using rule 24 (local_decl -> type_spec IDENT [ expr ] ; .)
    FOR             reduce using rule 24 (local_decl -> type_spec IDENT [ expr ] ; .)
    WHILE           reduce using rule 24 (local_decl -> type_spec IDENT [ expr ] ; .)
    IF              reduce using rule 24 (local_decl -> type_spec IDENT [ expr ] ; .)
    {               reduce using rule 24 (local_decl -> type_spec IDENT [ expr ] ; .)
    ;               reduce using rule 24 (local_decl -> type_spec IDENT [ expr ] ; .)
    NEW             reduce using rule 24 (local_decl -> type_spec IDENT [ expr ] ; .)
    STRING_LIT      reduce using rule 24 (local_decl -> type_spec IDENT [ expr ] ; .)
    CHAR_LIT        reduce using rule 24 (local_decl -> type_spec IDENT [ expr ] ; .)
    FLOAT_LIT       reduce using rule 24 (local_decl -> type_spec IDENT [ expr ] ; .)
    INT_LIT         reduce using rule 24 (local_decl -> type_spec IDENT [ expr ] ; .)
    FALSE           reduce using rule 24 (local_decl -> type_spec IDENT [ expr ] ; .)
    TRUE            reduce using rule 24 (local_decl -> type_spec IDENT [ expr ] ; .)
    BOOL_LIT        reduce using rule 24 (local_decl -> type_spec IDENT [ expr ] ; .)
    IDENT           reduce using rule 24 (local_decl -> type_spec IDENT [ expr ] ; .)
    (               reduce using rule 24 (local_decl -> type_spec IDENT [ expr ] ; .)
    DEC             reduce using rule 24 (local_decl -> type_spec IDENT [ expr ] ; .)
    INC             reduce using rule 24 (local_decl -> type_spec IDENT [ expr ] ; .)
    PLUS            reduce using rule 24 (local_decl -> type_spec IDENT [ expr ] ; .)
    MINUS           reduce using rule 24 (local_decl -> type_spec IDENT [ expr ] ; .)
    !               reduce using rule 24 (local_decl -> type_spec IDENT [ expr ] ; .)


state 165

    (39) for_stmt -> FOR ( args ; args ; . args ) stmt
    (87) args -> . empty
    (88) args -> . arg_list
    (89) empty -> .
    (85) arg_list -> . expr
    (86) arg_list -> . arg_list , expr
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING_LIT
    (47) expr -> . CHAR_LIT
    (48) expr -> . FLOAT_LIT
    (49) expr -> . INT_LIT
    (50) expr -> . FALSE
    (51) expr -> . TRUE
    (52) expr -> . BOOL_LIT
    (53) expr -> . IDENT . SIZE
    (54) expr -> . IDENT ( args )
    (55) expr -> . IDENT [ expr ]
    (56) expr -> . IDENT
    (57) expr -> . ( expr )
    (58) expr -> . expr DEC
    (59) expr -> . expr INC
    (60) expr -> . DEC expr
    (61) expr -> . INC expr
    (62) expr -> . PLUS expr
    (63) expr -> . MINUS expr
    (64) expr -> . ! expr
    (65) expr -> . expr MOD expr
    (66) expr -> . expr DIVIDE expr
    (67) expr -> . expr TIMES expr
    (68) expr -> . expr MINUS expr
    (69) expr -> . expr PLUS expr
    (70) expr -> . expr > expr
    (71) expr -> . expr GE expr
    (72) expr -> . expr < expr
    (73) expr -> . expr LE expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT [ expr ] = expr
    (79) expr -> . IDENT MODASSIGN expr
    (80) expr -> . IDENT DIVASSIGN expr
    (81) expr -> . IDENT MULASSIGN expr
    (82) expr -> . IDENT SUBASSIGN expr
    (83) expr -> . IDENT ADDASSIGN expr
    (84) expr -> . IDENT = expr
    )               reduce using rule 89 (empty -> .)
    NEW             shift and go to state 25
    STRING_LIT      shift and go to state 26
    CHAR_LIT        shift and go to state 27
    FLOAT_LIT       shift and go to state 28
    INT_LIT         shift and go to state 29
    FALSE           shift and go to state 30
    TRUE            shift and go to state 31
    BOOL_LIT        shift and go to state 32
    IDENT           shift and go to state 23
    (               shift and go to state 33
    DEC             shift and go to state 34
    INC             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    !               shift and go to state 38

    args                           shift and go to state 167
    empty                          shift and go to state 82
    arg_list                       shift and go to state 83
    expr                           shift and go to state 84

state 166

    (40) if_stmt -> IF ( expr ) stmt ELSE . stmt
    (29) stmt -> . break_stmt
    (30) stmt -> . return_stmt
    (31) stmt -> . for_stmt
    (32) stmt -> . while_stmt
    (33) stmt -> . if_stmt
    (34) stmt -> . compound_stmt
    (35) stmt -> . expr_stmt
    (44) break_stmt -> . BREAK ;
    (42) return_stmt -> . RETURN expr ;
    (43) return_stmt -> . RETURN ;
    (39) for_stmt -> . FOR ( args ; args ; args ) stmt
    (38) while_stmt -> . WHILE ( expr ) stmt
    (40) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (41) if_stmt -> . IF ( expr ) stmt
    (21) compound_stmt -> . { local_decls stmt_list }
    (36) expr_stmt -> . ;
    (37) expr_stmt -> . expr ;
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING_LIT
    (47) expr -> . CHAR_LIT
    (48) expr -> . FLOAT_LIT
    (49) expr -> . INT_LIT
    (50) expr -> . FALSE
    (51) expr -> . TRUE
    (52) expr -> . BOOL_LIT
    (53) expr -> . IDENT . SIZE
    (54) expr -> . IDENT ( args )
    (55) expr -> . IDENT [ expr ]
    (56) expr -> . IDENT
    (57) expr -> . ( expr )
    (58) expr -> . expr DEC
    (59) expr -> . expr INC
    (60) expr -> . DEC expr
    (61) expr -> . INC expr
    (62) expr -> . PLUS expr
    (63) expr -> . MINUS expr
    (64) expr -> . ! expr
    (65) expr -> . expr MOD expr
    (66) expr -> . expr DIVIDE expr
    (67) expr -> . expr TIMES expr
    (68) expr -> . expr MINUS expr
    (69) expr -> . expr PLUS expr
    (70) expr -> . expr > expr
    (71) expr -> . expr GE expr
    (72) expr -> . expr < expr
    (73) expr -> . expr LE expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT [ expr ] = expr
    (79) expr -> . IDENT MODASSIGN expr
    (80) expr -> . IDENT DIVASSIGN expr
    (81) expr -> . IDENT MULASSIGN expr
    (82) expr -> . IDENT SUBASSIGN expr
    (83) expr -> . IDENT ADDASSIGN expr
    (84) expr -> . IDENT = expr
    BREAK           shift and go to state 131
    RETURN          shift and go to state 133
    FOR             shift and go to state 135
    WHILE           shift and go to state 136
    IF              shift and go to state 137
    {               shift and go to state 78
    ;               shift and go to state 132
    NEW             shift and go to state 25
    STRING_LIT      shift and go to state 26
    CHAR_LIT        shift and go to state 27
    FLOAT_LIT       shift and go to state 28
    INT_LIT         shift and go to state 29
    FALSE           shift and go to state 30
    TRUE            shift and go to state 31
    BOOL_LIT        shift and go to state 32
    IDENT           shift and go to state 23
    (               shift and go to state 33
    DEC             shift and go to state 34
    INC             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    !               shift and go to state 38

    expr                           shift and go to state 134
    stmt                           shift and go to state 168
    break_stmt                     shift and go to state 124
    return_stmt                    shift and go to state 125
    for_stmt                       shift and go to state 126
    while_stmt                     shift and go to state 127
    if_stmt                        shift and go to state 128
    compound_stmt                  shift and go to state 129
    expr_stmt                      shift and go to state 130

state 167

    (39) for_stmt -> FOR ( args ; args ; args . ) stmt
    )               shift and go to state 169


state 168

    (40) if_stmt -> IF ( expr ) stmt ELSE stmt .
    }               reduce using rule 40 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    BREAK           reduce using rule 40 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    RETURN          reduce using rule 40 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    FOR             reduce using rule 40 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    WHILE           reduce using rule 40 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    IF              reduce using rule 40 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    {               reduce using rule 40 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    ;               reduce using rule 40 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    NEW             reduce using rule 40 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    STRING_LIT      reduce using rule 40 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    CHAR_LIT        reduce using rule 40 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    FLOAT_LIT       reduce using rule 40 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    INT_LIT         reduce using rule 40 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    FALSE           reduce using rule 40 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    TRUE            reduce using rule 40 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    BOOL_LIT        reduce using rule 40 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    IDENT           reduce using rule 40 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    (               reduce using rule 40 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    DEC             reduce using rule 40 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    INC             reduce using rule 40 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    PLUS            reduce using rule 40 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    MINUS           reduce using rule 40 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    !               reduce using rule 40 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    ELSE            reduce using rule 40 (if_stmt -> IF ( expr ) stmt ELSE stmt .)


state 169

    (39) for_stmt -> FOR ( args ; args ; args ) . stmt
    (29) stmt -> . break_stmt
    (30) stmt -> . return_stmt
    (31) stmt -> . for_stmt
    (32) stmt -> . while_stmt
    (33) stmt -> . if_stmt
    (34) stmt -> . compound_stmt
    (35) stmt -> . expr_stmt
    (44) break_stmt -> . BREAK ;
    (42) return_stmt -> . RETURN expr ;
    (43) return_stmt -> . RETURN ;
    (39) for_stmt -> . FOR ( args ; args ; args ) stmt
    (38) while_stmt -> . WHILE ( expr ) stmt
    (40) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (41) if_stmt -> . IF ( expr ) stmt
    (21) compound_stmt -> . { local_decls stmt_list }
    (36) expr_stmt -> . ;
    (37) expr_stmt -> . expr ;
    (45) expr -> . NEW type_spec [ expr ]
    (46) expr -> . STRING_LIT
    (47) expr -> . CHAR_LIT
    (48) expr -> . FLOAT_LIT
    (49) expr -> . INT_LIT
    (50) expr -> . FALSE
    (51) expr -> . TRUE
    (52) expr -> . BOOL_LIT
    (53) expr -> . IDENT . SIZE
    (54) expr -> . IDENT ( args )
    (55) expr -> . IDENT [ expr ]
    (56) expr -> . IDENT
    (57) expr -> . ( expr )
    (58) expr -> . expr DEC
    (59) expr -> . expr INC
    (60) expr -> . DEC expr
    (61) expr -> . INC expr
    (62) expr -> . PLUS expr
    (63) expr -> . MINUS expr
    (64) expr -> . ! expr
    (65) expr -> . expr MOD expr
    (66) expr -> . expr DIVIDE expr
    (67) expr -> . expr TIMES expr
    (68) expr -> . expr MINUS expr
    (69) expr -> . expr PLUS expr
    (70) expr -> . expr > expr
    (71) expr -> . expr GE expr
    (72) expr -> . expr < expr
    (73) expr -> . expr LE expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT [ expr ] = expr
    (79) expr -> . IDENT MODASSIGN expr
    (80) expr -> . IDENT DIVASSIGN expr
    (81) expr -> . IDENT MULASSIGN expr
    (82) expr -> . IDENT SUBASSIGN expr
    (83) expr -> . IDENT ADDASSIGN expr
    (84) expr -> . IDENT = expr
    BREAK           shift and go to state 131
    RETURN          shift and go to state 133
    FOR             shift and go to state 135
    WHILE           shift and go to state 136
    IF              shift and go to state 137
    {               shift and go to state 78
    ;               shift and go to state 132
    NEW             shift and go to state 25
    STRING_LIT      shift and go to state 26
    CHAR_LIT        shift and go to state 27
    FLOAT_LIT       shift and go to state 28
    INT_LIT         shift and go to state 29
    FALSE           shift and go to state 30
    TRUE            shift and go to state 31
    BOOL_LIT        shift and go to state 32
    IDENT           shift and go to state 23
    (               shift and go to state 33
    DEC             shift and go to state 34
    INC             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    !               shift and go to state 38

    stmt                           shift and go to state 170
    break_stmt                     shift and go to state 124
    return_stmt                    shift and go to state 125
    for_stmt                       shift and go to state 126
    while_stmt                     shift and go to state 127
    if_stmt                        shift and go to state 128
    compound_stmt                  shift and go to state 129
    expr_stmt                      shift and go to state 130
    expr                           shift and go to state 134

state 170

    (39) for_stmt -> FOR ( args ; args ; args ) stmt .
    }               reduce using rule 39 (for_stmt -> FOR ( args ; args ; args ) stmt .)
    BREAK           reduce using rule 39 (for_stmt -> FOR ( args ; args ; args ) stmt .)
    RETURN          reduce using rule 39 (for_stmt -> FOR ( args ; args ; args ) stmt .)
    FOR             reduce using rule 39 (for_stmt -> FOR ( args ; args ; args ) stmt .)
    WHILE           reduce using rule 39 (for_stmt -> FOR ( args ; args ; args ) stmt .)
    IF              reduce using rule 39 (for_stmt -> FOR ( args ; args ; args ) stmt .)
    {               reduce using rule 39 (for_stmt -> FOR ( args ; args ; args ) stmt .)
    ;               reduce using rule 39 (for_stmt -> FOR ( args ; args ; args ) stmt .)
    NEW             reduce using rule 39 (for_stmt -> FOR ( args ; args ; args ) stmt .)
    STRING_LIT      reduce using rule 39 (for_stmt -> FOR ( args ; args ; args ) stmt .)
    CHAR_LIT        reduce using rule 39 (for_stmt -> FOR ( args ; args ; args ) stmt .)
    FLOAT_LIT       reduce using rule 39 (for_stmt -> FOR ( args ; args ; args ) stmt .)
    INT_LIT         reduce using rule 39 (for_stmt -> FOR ( args ; args ; args ) stmt .)
    FALSE           reduce using rule 39 (for_stmt -> FOR ( args ; args ; args ) stmt .)
    TRUE            reduce using rule 39 (for_stmt -> FOR ( args ; args ; args ) stmt .)
    BOOL_LIT        reduce using rule 39 (for_stmt -> FOR ( args ; args ; args ) stmt .)
    IDENT           reduce using rule 39 (for_stmt -> FOR ( args ; args ; args ) stmt .)
    (               reduce using rule 39 (for_stmt -> FOR ( args ; args ; args ) stmt .)
    DEC             reduce using rule 39 (for_stmt -> FOR ( args ; args ; args ) stmt .)
    INC             reduce using rule 39 (for_stmt -> FOR ( args ; args ; args ) stmt .)
    PLUS            reduce using rule 39 (for_stmt -> FOR ( args ; args ; args ) stmt .)
    MINUS           reduce using rule 39 (for_stmt -> FOR ( args ; args ; args ) stmt .)
    !               reduce using rule 39 (for_stmt -> FOR ( args ; args ; args ) stmt .)
    ELSE            reduce using rule 39 (for_stmt -> FOR ( args ; args ; args ) stmt .)
